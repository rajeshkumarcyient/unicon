/*
 * Merr file for Icon, from parserr.h -- table of parser error messages.
 *
 * Each entry maps a syntax error from a particular Yacc state into a
 * descriptive message. However, the Yacc states are given by example
 * error fragments. Merr needs to be rerun on this file whenever the
 * grammar is changed.
 */

%%
if x
::: invalid declaration
::: end of file expected 1
global x end
::: invalid declaration
global x y
::: comma expected
record end
::: identifier (record name) expected
::: missing semicolon 12
link end
::: link list expected
invocable end
::: invocable list expected
procedure end
::: identifier (procedure name) expected
::: invalid declaration 17
::: missing record name 18
global end
::: invalid global declaration
::: missing procedure name 30
record foo end
::: missing field list in record declaration
::: missing end 34
procedure p(); 1 := 2 end
::: missing semicolon or operator
procedure main()
every x do { }
}
end
::: too many closing curly braces
procedure p()
    write("hello")
link
::: missing semicolon or "end"
procedure p(x); @ end
::: invalid argument for unary operator
procedure p(x); not end
::: invalid argument for unary operator
procedure p(x); | end
::: invalid argument for unary operator
procedure p(x); || end
::: invalid argument for unary operator
procedure p(x); ||| end
::: invalid argument for unary operator
procedure p(x); . end
::: invalid argument for unary operator
procedure p(x); ! end
::: invalid argument for unary operator
procedure p(x); -- end
::: invalid argument for unary operator
procedure p(x); + end
::: invalid argument for unary operator
procedure p(x); * end
::: invalid argument for unary operator
procedure p(x); / end
::: invalid argument for unary operator
procedure p(x); ^ end
::: invalid argument for unary operator
procedure p(x); ** end
::: invalid argument for unary operator
procedure p(x); ~ end
::: invalid argument for unary operator
procedure p(x); - end
::: invalid argument for unary operator
procedure p(x); = end
::: invalid argument for unary operator
procedure p(x); ~= end
::: invalid argument for unary operator
procedure p(x); == end
::: invalid argument for unary operator
procedure p(x); ~== end
::: invalid argument for unary operator
procedure p(x); === end
::: invalid argument for unary operator
procedure p(x); ++ end
::: invalid argument for unary operator
procedure p(x); ? end
::: invalid argument for unary operator
procedure p(x); ~=== end
::: invalid argument for unary operator
procedure p(x); \ end
::: invalid argument for unary operator
procedure p(x); create end
::: invalid create expression
procedure p(); while 1 do break end
::: invalid break expression
procedure p(x); ( end
::: invalid expression list
procedure p(); { end
::: invalid compound expression
procedure p(); [ end
::: invalid expression list
procedure p(x); & end
::: invalid keyword construction
procedure p(); while 1 do return end
::: invalid return expression
procedure p(); while 1 do suspend end
::: invalid suspend expression
procedure p(); if then
::: invalid if control expression
procedure p()
    case link
end
::: invalid case control expression
procedure p(); while do
::: invalid while control expression
procedure p(); until do
::: invalid until control expression
procedure p(); every do
::: invalid every control expression
procedure p(); repeat do
::: invalid repeat expression
link a, ;
::: missing link file name
invocable all, ; procedure p(); end
::: missing operation name
invocable "hey" : end
::: missing number of arguments
procedure main;
end
::: missing parameter list in procedure declaration
procedure main();
procedure
::: invalid procedure body
procedure main(); local end
::: invalid local declaration
procedure p(); initial do
::: invalid initial expression
procedure main(); write("x"); then
::: invalid expression
procedure main(); write("x"); procedure
::: invalid expression
procedure p(x); 1 & end
::: invalid argument
procedure p(x); 1 ? end
::: invalid argument
procedure p(x); 1 :=: end
::: invalid argument in swap
procedure p(x); 1 := end
::: invalid argument in assignment
procedure p(x); 1 <-> end
::: invalid argument in reversible swap
procedure p(x); 1 <- end
::: invalid argument in reversible assignment
procedure p(x); 1 ||:= end
::: invalid argument in augmented assignment
procedure p(x); 1 |||:= end
::: invalid argument in augmented assignment
procedure p(x); 1 --:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ++:= end
::: invalid argument in augmented assignment
procedure p(x); 1 +:= end
::: invalid argument in augmented assignment
procedure p(x); 1 -:= end
::: invalid argument in augmented assignment
procedure p(x); 1 *:= end
::: invalid argument in augmented assignment
procedure p(x); 1 **:= end
::: invalid argument in augmented assignment
procedure p(x); 1 /:= end
::: invalid argument in augmented assignment
procedure p(x); 1 %:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ^:= end
::: invalid argument in augmented assignment
procedure p(x); 1 =:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ===:= end
::: invalid argument in augmented assignment
procedure p(x); 1 >=:= end
::: invalid argument in augmented assignment
procedure p(x); 1 >:= end
::: invalid argument in augmented assignment
procedure p(x); 1 <=:= end
::: invalid argument in augmented assignment
procedure p(x); 1 <:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ~=:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ~===:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ==:= end
::: invalid argument in augmented assignment
procedure p(x); 1 >>=:= end
::: invalid argument in augmented assignment
procedure p(x); 1 >>:= end
::: invalid argument in augmented assignment
procedure p(x); 1 <<=:= end
::: invalid argument in augmented assignment
procedure p(x); 1 <<:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ~==:= end
::: invalid argument in augmented assignment
procedure p(x); 1 ?:= end
::: invalid argument in augmented assignment
procedure p(x); 1 &:= end
::: invalid argument in augmented assignment
procedure p(x); 1 @:= end
::: invalid argument in augmented assignment
procedure p(x); 1 to end
::: invalid to clause
procedure p(x); 1 | end
::: invalid argument in alternation
procedure p(x); 1 == end
::: invalid argument
procedure p(x); 1 >>= end
::: invalid argument
procedure p(x); 1 >> end
::: invalid argument
procedure p(x); 1 <<= end
::: invalid argument
procedure p(x); 1 << end
::: invalid argument
procedure p(x); 1 ~== end
::: invalid argument
procedure p(x); 1 = end
::: invalid argument
procedure p(x); 1 >==:= end
::: invalid argument
procedure p(x); 1 > end
::: invalid argument
procedure p(x); 1 <= end
::: invalid argument
procedure p(x); 1 < end
::: invalid argument
procedure p(x); 1 ~= end
::: invalid argument
procedure p(x); 1 === end
::: invalid argument
procedure p(x); 1 ~=== end
::: invalid argument
procedure p(x); 1 || end
::: invalid argument
procedure p(x); 1 ||| end
::: invalid argument
procedure p(x); 1 + end
::: invalid argument
procedure p(x); 1 -- end
::: invalid argument
procedure p()
    write("hello")++
end
::: invalid argument
procedure p(x); 1 - end
::: invalid argument
procedure p(x); 1 * end
::: invalid argument
procedure p(x); 1 ** end
::: invalid argument
procedure p(x); 1 / end
::: invalid argument
procedure p(x); 1 % end
::: invalid argument
procedure p(x); 1 ^ end
::: invalid argument
procedure p(x); 1 \ end
::: invalid argument
procedure p(x); 1 @ end
::: invalid argument
procedure p(x); 1 ! end
::: invalid argument
procedure p(); x[of
::: invalid subscript
procedure p(); p{of
::: invalid pdco list
procedure main(); write(of end
::: invalid expression list
procedure p(); r.of
::: invalid field name
procedure main(x) ; (1 end
::: missing right parenthesis
procedure main(x) ; {1 end
::: missing right brace
procedure main(x) ; [1 end
::: missing right bracket
procedure main(x) ; if 1 ; end
::: missing then
procedure p()
    case if x then y
end
::: missing of
global x , end
::: missing identifier
record foo( end
::: missing identifier or right parenthesis
record foo(x end
::: missing comma or right parenthesis
procedure main() 1 end
::: missing semi-colon
::: missing end 235
procedure main()
local x end
::: invalid declaration or missing semicolon
procedure main()
    initial 1 end
::: missing semicolon or operator
procedure p()
  x[1
end
::: missing right bracket
procedure p(); p{x) end
::: missing right brace
procedure p(); p(x} end
::: missing right parenthesis
::: invalid expression list 311
::: invalid expression 313
procedure p()
  suspend 1 do end
::: invalid do clause
procedure p(); if 1 then end
::: invalid then clause
procedure p()
    case x of 
end
::: missing left brace
procedure p(); while 1 do end
::: invalid do clause
procedure main()
until x do end
::: invalid do clause
procedure main()
every !x do end
::: invalid do clause
procedure main(x ;
::: invalid parameter list
procedure p(x); 1 to 2 by end
::: invalid by clause
procedure p(); x[1:] end
::: invalid section
procedure p(); p{1, end
::: invalid pdco list
procedure p()
    case x of {
end
::: invalid case clause
procedure p(x,y[)
::: missing right bracket
procedure p()
  x[1:2
end
::: missing right brace
procedure p(); if 1 then 2 else else
::: invalid else clause
::: missing right brace or semicolon 351
procedure p()
  case 1 of { 1 : 2 ; default 3 end
::: missing colon
procedure p()
    case x of { 1
end
::: missing colon or ampersand
procedure p()
    case 1 of { x : y ;
end
::: invalid case clause
procedure p()
    case x of { default:
end
::: invalid default clause
procedure p()
    case x of { 1 :
end
::: invalid case clause
