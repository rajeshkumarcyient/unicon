############################################################################
#
#	File:     gui.icn
#
#	Subject:  Set of classes for GUI objects in Unicon
#
#	Authors:  Robert Parlett, Clint Jeffery, Susie Jeffery
#
#	Date:     16 January, 2001
#
############################################################################
#
#   This file is in the public domain.
#
############################################################################
#
#   This file provides an implementation of several common GUI
#   objects.  See the documentation supplied for full details.
#
############################################################################
#
#  Links: graphics, enqueue
#
############################################################################

link graphics, enqueue

$include "keysyms.icn"
$include "guiconst.icn"
$include "posix.icn"

$define SB_SIZE 22

##
#
# A class for an object with a ticker.
# This class should be subclassed by a class that wishes to
# have a ticker facility, namely implement a method that is
# called repeatedly at set intervals.
#
class Ticker(
   ticker_rate,             # Ticker rate
   next_tick_time           # Time of next tick
   )

   ##
   #  This method should be overridden by the subclass.  It will
   #  be called repeatedly.
   #
   method tick()
      error("tick() must be overridden in subclass")
   end


   ##
   #  Start the ticker process, with the {tick()}
   #  method being invoked approximately every {n} milliseconds.
   #
   #  @param n   the ticker interval in milliseconds.
   #
   method set_ticker(n)
      dispatcher$set_ticker(self, n)
   end

   ##
   #  Stop the ticker.
   #
   method stop_ticker()
      dispatcher$stop_ticker(self)
   end

   ##
   #  Change the interval of the ticker
   #  @param n   the new interval.
   #
   method retime_ticker(n)
      dispatcher$retime_ticker(self, n)
   end

   ##
   #  Succeeds if and only if the ticker is active.
   #
   method is_ticking()
      return \ticker_rate
   end

   initially
end

##
#
# This class handles Icon events, dispatching them to
# the appropriate dialog.  It also controls any active Tickers,
# activating them between events as and when appropriate.
#
class Dispatcher(
   dialogs,
   tickers,
   ticker_sleep,
   ticker_sleep_min,
   ticker_sleep_max
   )

   ##
   #
   # The single instance of the Dispatcher class.
   #
   global dispatcher

   #
   # Compute the ticker sleep rate.
   #
   method compute_ticker_sleep()
      if *tickers = 0 then
         ticker_sleep := ticker_sleep_max
      else {
         #
         # Get minimum ticker rate
         #
         ticker_sleep := &null
         every n := (!tickers).ticker_rate do
            (/ticker_sleep := n) | (ticker_sleep >:= n)
         #
         # Divide by number of tickers so that tickers with same tick
         # rate are still scheduled correctly.
         #
         ticker_sleep /:= *tickers
         #
         # Make between 10 and 50; not too quick to give a busy wait, not
         # too slow that events are not processed promptly.
         #
         ticker_sleep <:= ticker_sleep_min
         ticker_sleep >:= ticker_sleep_max
      }
   end

   #
   # Time of day
   #
   method curr_time_of_day()
      local t
      # posix_timeval() # what is this doing here?
      t := gettimeofday()
      return t[1] * 1000 + t[2] / 1000
   end

   #
   # Delete a ticker
   #
   method stop_ticker(d)
      if \d.ticker_rate then {
         delete(tickers, d)
         d.ticker_rate := &null
         compute_ticker_sleep()
      }
   end

   #
   # Add a ticker, or reset its time to a new value.
   #
   method set_ticker(d, n)
      insert(tickers, d)
      d.next_tick_time := 0
      d.ticker_rate := n
      compute_ticker_sleep()
   end

   #
   # Change a ticker's tick rate, to take effect after its
   # next tick.
   #
   method retime_ticker(d, n)
      d.ticker_rate := n
      compute_ticker_sleep()
   end

   #
   # Sleep for n milliseconds
   #
   method sleep(n)
      select([], \n)
   end

   #
   # Schedule a ticker
   #
   method ticker_schedule()
      local curr_time, d, bag

      curr_time := curr_time_of_day()
      bag := []
      every d := !tickers do {
         if curr_time >= d.next_tick_time then
            put(bag, d)
      }
      if d := ?bag then {
         d$tick()
         #
         # We have to take into account the fact that d$tick() may
         # delete itself as a ticker.
         #
         d.next_tick_time := \d.ticker_rate + curr_time_of_day()
      }
   end

   #
   # Add a dialog
   #
   method add(d)
      insert(dialogs, d)
   end

   #
   # Delete a dialog
   #
   method del(d)
      delete(dialogs, d)
   end

   #
   # Loop until dialog r is closed processing events and tickers.
   #
   method message_loop(r)
      local w, bag, d

      while \r.is_open do {
         bag := []
         every d := !dialogs do {
            if *Pending(d.win) > 0 then {
               if /d.is_blocked_flag then
                  put(bag, d)
               else {
                  while *Pending(d.win) > 0 do {
                     #
                     # Discard the event and beep in the window.
                     #
                     e := Event(d.win)
                     if not(integer(e) = (&lrelease | &rrelease | &mrelease | &ldrag | &rdrag | &mdrag)) then
                        Alert(d.win)
                  }
               }
            }
         }
         if d := ?bag then {
            d$process_event(Event(d.win))
            }
         else {
            ticker_schedule()
            sleep(ticker_sleep)
         }
      }
   end

   #
   # Return a list of unblocked dialogs.
   #
   method list_unblocked()
      local d, res

      res := []
      every d := !dialogs do
         if /d.is_blocked_flag then
            put(res, d)

      return res
   end

   initially
      dialogs := set([])
      tickers := set([])
      ticker_sleep_min := 10
      ticker_sleep_max := 50
      compute_ticker_sleep()
end

##
#
# An instance of this class is used to represent an event.
#
class _Event(
   event,                   # The Icon event
   component,               # The Component producing the event
   code                     # The integer code number for different event types.
   )

   ##
   #  Returns the Icon event associated with the event.
   #
   method get_event()
      return self.event
   end

   method set_event(x)
      return self.event := x
   end

   ##
   #  Returns an additional field to distinguish between different
   #  types of event generated by the same component.  For
   #  example, a TextField produces a code of zero when return is
   #  pressed, and a code of one when the contents are changed.
   #
   method get_code()
      return self.code
   end

   method set_code(x)
      return self.code := x
   end

   ##
   #  Returns the component associated with the event.  This may
   #  be a subclass of either Component or a MenuComponent.
   #
   method get_component()
      return self.component
   end

   method set_component(x)
      return self.component := x
   end
end

##
#
#  This is the parent class of a dialog window.
#
class _Dialog : Container(
   win,                     # The dialog's window.
   is_open,                 # Flag indicates whether window is open
   owning_dialog,
   child_dialogs,
   focus,                   # Component with current focus
   unique_flag,             # Flag indicates whether in unique processing mode
   re_process_flag,         # Flag indicates whether to distribute last
                            # Icon event during unique mode
   buffer_win,              # Buffer window for double buffering
   min_width,               # Minimum size of window.
   min_height,              #
   click_count,             # Variables controlling multiple clicks
   double_click_delay,
   repeat_delay,            # Repeat event delays
   repeat_rate,
   prev_x,
   prev_y,
   prev_time,
   prev_event,
   is_blocked_flag,
   resize_attrib
   )

   method is_shaded()
      return \self.is_shaded_flag
   end

   method is_unshaded()
      return /self.is_shaded_flag
   end

   method is_hidden()
      fail
   end

   method is_unhidden()
      return
   end

   method block()
      self.is_blocked_flag := 1
      self.resize_attrib := WAttrib(self.win, "resize")
      WAttrib(self.win, "resize=off")
   end

   method unblock()
      self.is_blocked_flag := &null
      WAttrib(self.win, "resize=" || self.resize_attrib)
   end

   ##
   #  Returns the number of mouse clicks that have occurred
   #  consecutively, with each click in the sequence being less
   #  than {double_click_delay} milliseconds apart.  That variable is by default 500
   #  milliseconds, but it may be configured with {set_double_click_delay().}
   #
   method get_click_count()
      return self.click_count
   end

   method get_x_reference()
      return 0
   end

   method get_y_reference()
      return 0
   end

   method get_w_reference()
      return WAttrib(self.win, "width")
   end

   method get_h_reference()
      return WAttrib(self.win, "height")
   end

   method get_cwin_reference()
      return self.win
   end

   method get_visible_reference()
      fail
   end

   ##
   #  This is a variation on the conventional modal and modeless
   #  methods.  The dialog is opened, input to other windows is not blocked, but
   #  the call does not return until the window is closed.
   #  @param d   The parent dialog, if specified, is blocked until
   #  @ the window is closed.
   #
   method show_child(d)
      self$show()
      dispatcher$add(self)
      if \d then {
         insert(d.child_dialogs, self)
         self.owning_dialog := d
         d$block()
         dispatcher$message_loop(self)
         d$unblock()
      } else
         dispatcher$message_loop(self)
   end

   ##
   #  Displays the dialog as a modeless dialog.  This
   #  means that window events are processed by this dialog
   #  and other open dialogs concurrently.  The call to
   #  {show_modeless()} opens the dialog and returns immediately.
   #
   #  @param d   This optional parameter specifies the parent dialog.
   #  @ When a parent dialog is closed, its child dialogs are automatically closed.
   #
   method show_modeless(d)
      self$show()
      dispatcher$add(self)
      if \d then {
         insert(d.child_dialogs, self)
         self.owning_dialog := d
         self.is_blocked_flag := d.is_blocked_flag
      }
   end

   ##
   #  Displays the dialog as a modal dialog.  In other
   #  words, window events to any other open dialogs are blocked
   #  until the dialog is closed.  This method doesn't return
   #  until the dialog is closed.
   #  @param d   The parent dialog.  It will not normally be
   #  @ needed.
   #
   method show_modal(d)
      self$show()
      if \d then {
         insert(d.child_dialogs, self)
         self.owning_dialog := d
      }
      l := dispatcher$list_unblocked()
      every (!l)$block()
      dispatcher$add(self)
      dispatcher$message_loop(self)
      every (!l)$unblock()
   end

   method get_cbwin_reference()
      return self.buffer_win
   end

   ##
   #  Returns the Icon window associated with the dialog.
   #
   method get_win()
      return self.win
   end

   method resize_win(w, h)
      WAttrib(self.win, "size=" || w || "," || h)
      Enqueue(self.win, &resize)
   end

   method Open()
   local attr
      attr := ["inputmask=c"] ||| self.attribs
      self.win := (WOpen ! attr) | error("couldn't open window")
      self.buffer_win := (WOpen ! (["canvas=hidden"] ||| self.attribs)) | error("couldn't open buffer window")
      return
   end

   method Close()
      WClose(self.buffer_win)
      return WClose(self.win)
   end

   ##
   #  Sets the minimum dimensions for a window.  The user will not
   #  be able to resize the window below this size.
   #
   method set_min_size(w, h)
      self.min_width := w
      self.min_height := h
      return
   end

   method get_buffer_win()
      return self.buffer_win
   end

   method set_unique(c)
      /self.unique_flag := c | stop("internal error")
      return
   end

   method clear_unique(x)
      self.re_process_flag := x
      self.unique_flag := &null
      return
   end

   ##
   #  Sets keyboard focus to the given component.  This method
   #  should only be invoked after the dialog has been displayed.
   #  To give a component the initial keyboard focus,
   #  invoke this method from within {init_dialog()}
   #
   method set_focus(c)
      if \self.focus === c then
         return

      (\self.focus)$lost_focus()
      self.focus := c
      self.focus$got_focus()

      return
   end

   ##
   #  Clear the keyboard focus.
   #
   method clear_focus()
      (\self.focus)$lost_focus()
      self.focus := &null
      return
   end

   #
   # Display all components
   #
   method display(buffer_flag)
      if \buffer_flag then {
         EraseArea(buffer_win, 0, 0, get_w_reference(), get_h_reference())
         self$Container.display(1)
         CopyArea(buffer_win, win, 0, 0, get_w_reference(), get_h_reference(), 0, 0)
      } else {
         EraseArea(win, 0, 0, get_w_reference(), get_h_reference())
         self$Container.display()
      }
   end

   method init_dialog()
   end

   ##
   #  This empty method may be overridden to add components to the
   #  dialog.  Alternatively, components may be added in the
   #  dialog's {initially} method.
   #
   method component_setup()
   end

   ##
   #  This empty method may be overridden.  It is invoked just
   #  before the dialog window is closed.
   #
   method end_dialog()
   end

   method show()
      self$component_setup()
      self$Open()
      self$final_setup(self, self)
      self$resize()
      self$firstly()
      self.is_open := 1
      self$display()
      self$init_dialog()
   end

   method dispose(was_closed)
      self$end_dialog()
      every (!child_dialogs)$dispose()
      self$finally()
      if /was_closed then
         self$Close()
      self.is_open := &null
      dispatcher$del(self)
      delete((\owning_dialog).child_dialogs, self)
   end

   method process_event(e)
      if integer(e) = -11 then {
         dispose(1)
         }

      if integer(e) = (&lpress | &rpress | &mpress) then {
         t := dispatcher$curr_time_of_day()
         if e = \prev_event & prev_x = &x & prev_y = &y & (t - prev_time < double_click_delay) then
            click_count +:= 1
         else
            click_count := 1

         prev_event := e
         prev_time := t
         prev_x := &x
         prev_y := &y
      }

      if e === &resize then {
         delay(100) # ?
         while *Pending(self.win) > 0 & Pending(self.win)[1] === e do {
            e := Event(self.win)
            delay(50)
	    }
         nw := WAttrib(self.win, "width")
         nh := WAttrib(self.win, "height")

         #
         # Don't allow size to fall below minimum.
         #
         if nw <:= \self.min_width then
            WAttrib(self.win, "width=" || nw)

         if nh <:= \self.min_height then
            WAttrib(self.win, "height=" || nh)

         #
         # Resize buffer canvas
         #
         WAttrib(self.buffer_win, "width=" || nw)
         WAttrib(self.buffer_win, "height=" || nh)
         EraseArea(self.win, 0, 0, nw, nh)
         self$resize()
         self$display()
      }

      if e === (&ldrag | &rdrag | &mdrag) then {
         while *Pending(self.win) > 0 & Pending(self.win)[1] === e do {
            e := Event(self.win)
	    }
         }

      every E := (\self.unique_flag)$handle_event(e) do {
         self$dialog_event(E)
         if /self.is_open then
            return
      }

      if /self.unique_flag & /self.re_process_flag then {
         if integer(e) = (&lpress | &rpress | &mpress) then {
            if c := self$in_region() then
               self$set_focus(c)
            else
               self$clear_focus()
         }

         every E := self$handle_event(e) | _Event(e) do {
            self$dialog_event(E)
            if /self.is_open then
               return
         }

        if (string(e) == "\t") &
               (/self.focus | /self.focus.keeps_tabs) then {
           res := found := wrap := &null
           every c := self$generate_components() do {
              if c === self.focus then
                 found := 1
              else {
                 if c$accepts_tab_focus() then {
                    if /found then
                       /wrap := c
                    else {
                       res := c
                       break
                       }
                    }
                 }
            }
            self$set_focus(\res | \wrap)
         } else if integer(e) = \Shift_Tab then {
            res := &null
            every c := self$generate_components() do {
               if c === self.focus then {
                  if \res then
                     break
               } else {
                  if c$accepts_tab_focus() then
                     res := c
               }
            }
            self$set_focus(\res)
         }
      }
      self.re_process_flag := &null

      return
   end

   ##
   #  This method must be over-ridden in the subclass.  It is the
   #  method which is invoked when an event occurs.
   #  @param e   The instance of the {_Event} class to be processed.
   #
   method dialog_event(e)
      error("dialog_event() must be overridden in subclass")
   end

   ##
   #  Set the delay in milliseconds between double clicks.  The
   #  default is 500 milliseconds
   #
   method set_double_click_delay(i)
      return self.double_click_delay := i
   end

   ##
   #  Set the delay in milliseconds between an initial repeating event
   #  and the start of repeat events.   The
   #  default is 500 milliseconds
   #
   method set_repeat_delay(i)
      return self.repeat_delay := i
   end

   ##
   #  Set the delay in milliseconds between repeating events.
   #  The default is 100 milliseconds
   #
   method set_repeat_rate(i)
      return self.repeat_rate := i
   end

   method handle_notify(e)
      self$dialog_event(e)
   end

   initially
      self$Container.initially()
      self.attribs := ["bg=pale gray"]
      self.child_dialogs := set([])
      self.double_click_delay := 500
      self.repeat_delay := 500
      self.repeat_rate := 100
end

##
#  This is the parent class of all the GUI components.  All of
#  its methods and variables therefore apply to its sub-classes.
#
class Component : Ticker(
   ##
   #  x position as specified by {set_pos()}, eg "50%"
   #
   x_spec,
   ##
   #  y position as specified by set_pos().
   #
   y_spec,
   ##
   #  width specifier as specified in set_size(), eg "100%"
   #
   w_spec,
   ##
   # height specifier as specified in set_size(),
   #
   h_spec,
   ##
   #  x alignment as specified in set_align(), eg "l".
   #
   x_align,
   ##
   #  y alignment as specified in set_align(), eg "b".
   #
   y_align,
   ##
   #  Absolute x position in pixels computed from x_spec and the
   #  dimensions of the enclosing object or window.
   #
   x,
   ##
   #  Absolute y position.
   #
   y,
   ##
   #  Absolute width in pixels computed from w_spec and the
   #  dimensions of the enclosing object or window.
   w,
   ##
   #  Absolute height in pixels.
   #
   h,
   ##
   #  The {_Dialog} class instance of which this {Component} is a part.
   #
   parent_Dialog,
   ##
   #  A list of strings being the Icon graphics attributes, eg
   #  ["bg=blue", "resize=on"].
   attribs,
   ##
   #  Flag indicating whether the {Component} currently has keyboard
   #  focus; {&null} means it hasn't.
   has_focus,
   ##
   #  Flag indicating whether the {Component} currently is shaded;
   #  {&null} means it isn't.
   is_shaded_flag,
   ##
   #  A cloned window created by combining the Dialog's canvas
   #  with the Component's attributes, so drawing into this window
   #  will draw straight to the Dialog window with the correct
   #  attributes.
   cwin,
   ##
   #  A cloned window created by combining a buffer window with
   #  the {Component's} attributes.  This is used solely for
   #  double-buffering purposes.
   cbwin,
   ##
   #  Flag indicating whether the {Component} accepts keyboard focus
   #  by way of the tab key being pressed;  {&null} means it doesn't.
   accepts_tab_focus_flag,
   ##
   #  Flag indicating whether the Component should have a border
   #  drawn around it; {&null} means no.  Many {Components} (such as
   #  {TextButtons}) ignore this flag.
   draw_border_flag,
   no_updates_count,
   ##
   #  Tooltip string for use with {ToolBar} objects.
   #
   tooltip,
   ##
   #  Reference to enclosing {Component} object.
   #
   parent_Component,
   #
   # tells whether ordinary tab characters are used by the component;
   # if not, they shift focus to the next component.  shift-tab should
   # always shift focus to the next component.
   #
   keeps_tabs
   )

   ##
   #  Set a tooltip string.  This is presently only used by
   #  the {Toolbar} class.
   #
   method set_tooltip(x)
      return self.tooltip := x
   end

   method handle_notify(e)
      self.parent_Component$handle_notify(e)
   end

   method set_no_updates()
      return no_updates_count +:= 1
   end

   method clear_no_updates()
      no_updates_count -:= 1
      redisplay()
      return no_updates_count
   end

   method get_x_reference()
      return self.x
   end

   method get_y_reference()
      return self.y
   end

   method get_w_reference()
      return self.w
   end

   method get_h_reference()
      return self.h
   end

   method get_cwin_reference()
      return self.cwin
   end

   method get_cbwin_reference()
      return self.cbwin
   end

   method get_visible_reference()
      return self
   end

   method redisplay()
      if \(\self.parent_Dialog).is_open & (no_updates_count = 0) & is_unhidden() then
         self$display()
   end

   method error(s)
      stop("gui.icn : error whilst processing object " || object_class_name(self) || " : " || s)
   end

   ##
   #  Succeed if the component is hidden; for example if it is
   #  within a tabbed pane not presently visible.
   #
   method is_hidden()
      return self.parent_Component$is_hidden()
   end

   ##
   #  Succeed if the component is not hidden.
   #
   method is_unhidden()
      return self.parent_Component$is_unhidden()
   end

   ##
   #  Succeeds if the component is shaded; fails otherwise.  A
   #  shaded component, such as a button, may be displayed
   #  differently, and will not generate events.
   #
   method is_shaded()
      return \self.is_shaded_flag | self.parent_Component$is_shaded()
   end

   ##
   #  Succeed if the component is not shaded.
   #
   method is_unshaded()
      return /self.is_shaded_flag & self.parent_Component$is_unshaded()
   end

   ##
   #  Called from a component's {display()} method, this method
   #  filters the component to give a shaded appearance, if the
   #  {is_shaded_flag} is set.  {W} is the window to draw into
   #  (normally {self.cwin}).
   #
   method do_shading(W)
      if is_shaded() then
         FilterRectangle(W, self.x, self.y, self.w, self.h)
   end

   method accepts_tab_focus()
      return is_unshaded() & \self.accepts_tab_focus_flag
   end

   method unique_start()
      self.parent_Dialog$set_unique(self)
   end

   method unique_end(x)
      self.parent_Dialog$clear_unique(x)
   end

   ##
   #  This method is over-ridden by all this class's subclasses.
   #  It is the method which handles an Icon event e.  It would
   #  not normally be called by a user program.  It should either
   #  fail, or return an {_Event} structure.  This will then be
   #  passed to the  {dialog_event()} method of the dialog.  The
   #  first two fields of the _Event structure should be the Icon
   #  event e and the object itself.  The third field is the code,
   #  which can be any integer.
   #
   method handle_event(e)
      error("handle_event() method must be over-ridden in Component sub-class")
   end

   ##
   #  Swap the shaded status of the component.
   #
   method toggle_is_shaded()
      if /self.is_shaded_flag then
         self.is_shaded_flag := 1
      else
         self.is_shaded_flag := &null
      self$redisplay()
   end

   ##
   #  Set the shaded status of the component to shaded.
   #
   method set_is_shaded()
      self.is_shaded_flag := 1
      self$redisplay()
   end

   ##
   #  Set the shaded status of the component to not shaded.
   #
   method clear_is_shaded()
      self.is_shaded_flag := &null
      self$redisplay()
   end

   ##
   #  Toggle whether or not to draw a border around the component.
   #  Different objects respond differently to this flag being
   #  set; some ignore it altogether.
   #
   method toggle_draw_border()
      if /self.draw_border_flag then
         self.draw_border_flag := 1
      else
         self.draw_border_flag := &null
      self$redisplay()
   end

   ##
   #  Set the component such that a border is drawn.
   #
   method set_draw_border()
      self.draw_border_flag := 1
      self$redisplay()
   end

   ##
   #  Set the component such that a border is not drawn.
   #
   method clear_draw_border()
      self.draw_border_flag := &null
      self$redisplay()
   end

   method set_accepts_tab_focus()
      return self.accepts_tab_focus_flag := 1
   end

   method clear_accepts_tab_focus()
      return self.accepts_tab_focus_flag := &null
   end

   ##
   #  This draws, or re-draws, the component in the dialog
   #  window.
   #  @param buffer_flag   If this parameter is not null, then
   #  @ the component is displayed into the buffer window, not
   #  @ the dialog window (this is used for double-buffering purposes).
   #
   method display(buffer_flag)
      error("display() method must be over-ridden in Component sub-class")
   end

   ##
   #  Set the Icon attribs of the component to the given parameter
   #  @example
   #  @ w$set_attribs_list(["font=helvetica", "bg=pale blue"])
   #
   method set_attribs(x[])
      return self.attribs |||:= x
   end

   ##
   #  Equivalent to {set_attribs()}, above, but takes a list as a
   #  parameter.
   #  @param l   The list of attribs.
   #  @example
   #  @ w$set_attribs_list(["font=helvetica", "bg=pale blue"])
   #
   method set_attribs_list(l)
      return self.attribs |||:= l
   end

   ##
   #  Succeeds if the component is not shaded and the values of {&x}
   #  and {&y} lie within the component.
   #
   method in_region()
      if is_unshaded() & ((self.x <= &x < self.x + self.w) & (self.y  <= &y < self.y + self.h)) then
         return self
   end

   ##
   #  Method called when the component gets the keyboard focus; may be extended.
   #
   method got_focus()
      self.has_focus := 1
      redisplay()
   end

   ##
   #  Return the Icon window of the dialog in which the component resides.
   #
   method get_parent_win()
      return self.parent_Dialog$get_win()
   end

   method get_parent_buffer_win()
      return self.parent_Dialog$get_buffer_win()
   end

   ##
   #  Method called when the component loses the keyboard focus; may be extended.
   #
   method lost_focus()
      self.has_focus := &null
      redisplay()
   end

   ##
   #  Set the x and y position of the component.  Each coordinate
   #  can be either an absolute pixel position, or can be given in
   #  the form of a percentage plus or minus an offset.
   #  @param x_spec   The x specification.
   #  @param y_spec   The y specification.
   #  @example
   #  @ c$set_pos(100, "25%")
   #  @ c$set_pos("50%-20", "25%+100")
   #
   method set_pos(x_spec, y_spec)
      self.x_spec := x_spec
      self.y_spec := y_spec
      return
   end

   ##
   #  Set the size of the component.  The parameters are in the
   #  same format as for {set_pos()}
   #  above.  Some components will
   #  set sensible default sizes, but for others the size must be
   #  set explicitly.
   #
   method set_size(w_spec, h_spec)
      self.w_spec := w_spec
      self.h_spec := h_spec
      return
   end

   ##
   #  Set the alignment of the component.  Options for
   #  {x_align} are ``l'', ``c'' and ``r'', for left, centre, and right
   #  alignment.  Options for {y_align} are ``t'', ``c'' and ``b'',
   #  for top centre and bottom alignment.  The default alignment is ``l'', ``t''.
   #
   #  @param x_align   The x alignment
   #  @param y_align   The y alignment
   #
   method set_align(x_align, y_align)
      self.x_align := x_align
      self.y_align := y_align
   end

   method set_abs_coords(x, y)
      self.x := x
      self.y := y
      return
   end

   method set_abs_size(w, h)
      self.w := w
      self.h := h
      return
   end

   method final_setup(x, y)
      self.parent_Dialog := x
      self.parent_Component := y
      if self.cwin :=
         (Clone!([self.parent_Component$get_cwin_reference()]|||self.attribs)) 
      then {
         self.cbwin :=
            (Clone ! ([self.parent_Component$get_cbwin_reference()] |||
                       self.attribs))
         }
      else {
         write(&errout, "clone failed, discarding attributes:")
         every write(&errout, "\t", ! self.attribs)
	 self.cwin := (Clone ! ([self.parent_Component$get_cwin_reference()]))
         if / (self.cwin) then error("window system resource error")
         self.cbwin :=(Clone ! ([self.parent_Component$get_cbwin_reference()]))
         if / (self.cbwin) then error("window system resource error #2")
         }
      return x
   end

   ##
   #  Returns the dialog holding the component.
   #
   method get_parent_Dialog()
      return self.parent_Dialog
   end

   ##
   #  Sets the owning _Dialog of the component.  This method
   #  needs to be extended for a component which contains other
   #  components.
   #
   #  @param c   The parent dialog.
   #
   method set_parent_Dialog(c)
      return self.parent_Dialog := c
   end

   ##
   #  This method may be extended.  It is invoked after the
   #  position of the object has been computed and the window has
   #  been opened, but before the object has been displayed in the
   #  window.
   #
   method firstly()
   end

   ##
   #  This method may be extended.  It is invoked just before the
   #  window is closed.
   #
   method finally()
      stop_ticker()
      Uncouple(\ (self.cwin))
      Uncouple(\ (self.cbwin))
      self.cwin := self.cbwin := &null
      return
   end

   ##
   #
   # Parse a position specification into an absolute value.
   # @param total   The total value
   # @param s  The size specifier
   #
   method parse_pos(total, s)
      local pct, off
      s ? {
         if pct := real(0.01 * tab(upto('%'))) then {
            move(1)
            if ="-" then
               off := -integer(tab(0)) | fail
            else if ="+" then
               off := integer(tab(0)) | fail
            else off := 0
         } else {
            pct := 0
            off := integer(tab(0)) | fail
         }
      }
      return integer(pct * total + off)
   end

   ##
   #  Compute the absolute positions and sizes from the
   #  specifications given by {set_pos()} and {set_size()}.
   #  This method needs to be extended for a component which
   #  contains other components.
   #
   method resize()
      #
      # Check for unspecified fields
      #
      if /self.x_spec then
         error("x position unspecified")

      if /self.y_spec then
         error("y position unspecified")

      if /self.w_spec then
         error("width unspecified")

      if /self.h_spec then
         error("height unspecified")

      wh := self.parent_Component$get_h_reference()
      ww := self.parent_Component$get_w_reference()

      self.x := self.parent_Component$get_x_reference() + parse_pos(ww, self.x_spec) | error("invalid x position specification")
      self.y := self.parent_Component$get_y_reference() + parse_pos(wh, self.y_spec) | error("invalid y position specification")
      self.w := parse_pos(ww, self.w_spec) | error("invalid width specification")
      self.h := parse_pos(wh, self.h_spec) | error("invalid height specification")

      #
      # Adjust x, y based on alignments
      #
      case self.x_align of {
         "c" : self.x -:= self.w / 2
         "r" : self.x -:= self.w
         "l" : &null
         default :
            error("\nincorrect x alignment specifier " || image(self.x_align))
      }
      case self.y_align of {
         "c" : self.y -:= self.h / 2
         "b" : self.y -:= self.h
         "t" : &null
         default :
            error("\nincorrect y alignment specifier " || image(self.y_align))
      }

      return
   end

   ##
   #  Generate all the components that are visible in this
   #  component (which may be a container).
   #
   method generate_components()
      return self
   end

   ##
   #  Generate all the components, including non-visible ones in
   #  this component.
   #
   method generate_all_components()
      return self
   end

   initially
      /dispatcher := Dispatcher()
      self$Ticker.initially()
      self.attribs := []
      self.x_align := "l"
      self.y_align := "t"
      no_updates_count := 0
end

#
#  This class acts as a container for other components.  The
#  component itself is not displayable.
#
#  A {_Dialog} instance is a sub-class of this class.
#
class Container : Component(
   components
   )

   method get_x_reference()
      return self.parent_Component$get_x_reference()
   end

   method get_y_reference()
      return self.parent_Component$get_y_reference()
   end

   method get_w_reference()
      return self.parent_Component$get_w_reference()
   end

   method get_h_reference()
      return self.parent_Component$get_h_reference()
   end

   method get_cwin_reference()
      return self.parent_Component$get_cwin_reference()
   end

   method get_cbwin_reference()
      return self.parent_Component$get_cbwin_reference()
   end

   method get_visible_reference()
      return self.parent_Component$get_visible_reference()
   end

   method generate_components()
      suspend (!self.components)$generate_components()
   end

   method generate_all_components()
      suspend (!self.components)$generate_all_components() | self
   end

   ##
   #  Add the {Component} to the {Container}.
   #  @param c   The {Component} to add.
   #
   method add(c)
      put(self.components, c)
   end

   ##
   #  Set the list of {Components} in this {Container}.
   #  @param x   The list of {Components}.
   #
   method set_components(x)
      return self.components := x
   end

   ##
   #  Get the list of {Components} in this {Container}.
   #  @return   The list of {Components}
   #
   method get_components()
      return self.components
   end

   method display(buffer_flag)
      every (!self.components)$display(buffer_flag)
      return
   end

   method firstly()
      every (!self.components)$firstly()
      return
   end

   method final_setup(x, y)
      self.parent_Dialog := x
      self.parent_Component := y
      every (!self.components)$final_setup(x, self)
      return
   end

   method finally()
      stop_ticker()
      every (!self.components)$finally()
      return
   end

   method resize()
      every (!self.components)$resize()
      return
   end

   method handle_event(e)
      local c
      every c := !self.components do {
         if /c.is_shaded_flag then
            suspend c$handle_event(e)
         if \self.parent_Dialog.unique_flag then
            break
      }
   end

   method in_region()
      return (!self.components)$in_region()
   end

   initially
      self$Component.initially()
      self.components := []
end

##
#  This is similar to a Container, except that the object
#  itself is a capable of display.  A {VisibleContainer} should not
#  be instantiated itself; rather one of its subclasses should be
#  instantiated.
#
class VisibleContainer : Component(
   components
   )

   method generate_components()
      suspend (!self.components)$generate_components() | self
   end

   method generate_all_components()
      suspend (!self.components)$generate_all_components() | self
   end

   method in_region()
      return (!self.components)$in_region() | self$Component.in_region()
   end

   method resize()
      self$Component.resize()
      every (!self.components)$resize()
   end

   ##
   #  Add the {Component} to the {Container}.
   #  @param c   The {Component} to add.
   #
   method add(c)
      put(self.components, c)
   end

   ##
   #  Set the list of {Components} in this {Container}.
   #  @param x   The list of {Components}.
   #
   method set_components(x)
      return self.components := x
   end

   ##
   #  Get the list of {Components} in this {Container}.
   #  @return   The list of {Components}
   #
   method get_components()
      return self.components
   end

   method firstly()
      self$Component.firstly()
      every (!self.components)$firstly()
      return
   end

   method final_setup(x, y)
      self$Component.final_setup(x, y)
      every (!self.components)$final_setup(x, self)
      return
   end

   method finally()
      self$Component.finally()
      every (!self.components)$finally()
      return
   end

   initially
      self$Component.initially()
      self.components := []
end

##
#  A Panel of components.  This subclass of {VisibleContainer} just
#  implements the methods {display} and {handle_event}, to display and
#  forward events to all of its components.
#
class Panel : VisibleContainer()
   method display(buffer_flag)
      every (!self.components)$display(buffer_flag)
      return
   end

   method handle_event(e)
      local c
      every c := !self.components do {
         if /c.is_shaded_flag then
            suspend c$handle_event(e)
         if \self.parent_Dialog.unique_flag then
            break
      }
   end
end

##
#  This is a class for representing objects which can have an
#  on-off state, in particular checkboxes, toggle buttons,
#  and menu checkboxes.
#
class Toggle(
   parent_check_box_group,
   is_checked_flag
   )

   ##
   #  This empty method may be overridden; it is invoked when the
   #  object is added to a {CheckBoxGroup}.  Note that it is
   #  overridden by some of the subclasses described below.
   #
   method into_cbg()
   end

   ##
   #  Set the parent {CheckBoxGroup}.
   #  @param x   The parent {CheckBoxGroup}.
   #
   method set_parent_check_box_group(x)
      return self.parent_check_box_group := x
   end

   ##
   #  Succeed if the object is checked.
   #
   method is_checked()
      return \self.is_checked_flag
   end

   ##
   #  Return the status of the object; {1} if the object is checked,
   #  {&null} otherwise.
   #
   method get_status()
      return self.is_checked_flag
   end

   ##
   #  Toggle the status of the object.
   #
   method toggle_is_checked()
      if /self.is_checked_flag then
         self.is_checked_flag := 1
      else
         self.is_checked_flag := &null
   end

   ##
   #  Set the status to checked.
   #
   method set_is_checked()
      return self.is_checked_flag := 1
   end

   ##
   #  Set the status to unchecked.
   #
   method clear_is_checked()
      self.is_checked_flag := &null
   end
end

##
#  This class provides a component which can be dragged across the
#  window, allowing panes within the window to be resized.  An {Event} is
#  generated when the {Sizer} has been dragged and released.  The new position
#  may then be obtained and the dialog adjusted accordingly.
#
#
class Sizer : Component(
   is_held,
   is_horizontal_flag,
   temp_pointer,
   temp_win,                #
   temp_w,
   temp_h,
   min,
   max,
   drag_offset,
   curr_pos,
   start_pos,
   end_pos
   )

   ##
   #  Set the minimum and maximum values for the {Sizer}.  Whether these are
   #  x or y values depends on the orientation of the {Sizer}.
   #
   method set_min_max(min, max)
      self.min := min
      self.max := max
   end

   ##
   #  Return the current position of the {Sizer}.  This may be invoked to determine
   #  where the {Sizer} has been dragged to after it has generated an event.
   #
   method get_curr_pos()
      return curr_pos
   end

   ##
   #  Get the size of the move during the last drag of the {Sizer}.
   #
   method get_delta()
      return end_pos - start_pos
   end

   ##
   #  Configure the {Sizer} to be horizontal; the default is vertical.
   #
   method set_is_horizontal()
      return self.is_horizontal_flag := 1
   end

   method finally()
      if \self.is_held then {
         WClose(self.temp_win)
         unique_end()
      }
      self$Component.finally()
   end

   method display(buffer_flag)
      local cw
      W := if /buffer_flag then self.cwin else self.cbwin
      if \self.is_held then {
         CopyArea(temp_win, get_parent_buffer_win(), 0, 0, temp_w, temp_h, 0, 0)
         cw := Clone(self.cbwin, "linewidth=4", "pattern=gray", "fillstyle=masked")
         if \is_horizontal_flag then {
            abs_pos := curr_pos + drag_offset + parent_Component$get_y_reference()
            DrawLine(cw, x, abs_pos, x + w, abs_pos)
         } else {
            abs_pos := curr_pos + drag_offset + parent_Component$get_x_reference()
            DrawLine(cw, abs_pos, y, abs_pos, y + h)
         }
         Uncouple(cw)
         CopyArea(get_parent_buffer_win(), get_parent_win(), 0, 0, temp_w, temp_h, 0, 0)
      }
   end

   method set_curr_pos()
      if \self.is_horizontal_flag then
         curr_pos := &y - drag_offset - parent_Component$get_y_reference()
      else
         curr_pos := &x - drag_offset - parent_Component$get_x_reference()

      curr_pos <:= min
      curr_pos >:= max
      return curr_pos
   end

   method handle_event(e)
      if integer(e) = (&lpress | &rpress | &mpress) then {
         if self$in_region() then {
            unique_start()
            self.is_held := 1
            temp_w := parent_Dialog$get_w_reference()
            temp_h := parent_Dialog$get_h_reference()
            self.temp_win := WOpen("canvas=hidden", "size=" || temp_w || "," || temp_h)
            temp_pointer := WAttrib(get_parent_win(), "pointer")
            CopyArea(get_parent_win(), temp_win, 0, 0, temp_w, temp_h, 0, 0)
            if \self.is_horizontal_flag then {
               drag_offset := &y - self.y
               WAttrib(get_parent_win(), "pointer=sb v double arrow")
            } else {
               drag_offset := &x - self.x
               WAttrib(get_parent_win(), "pointer=sb h double arrow")
            }
            start_pos := set_curr_pos()
            display()
         }
      } else if \self.is_held then {
         if integer(e) = (&ldrag | &rdrag | &mdrag) then {
            set_curr_pos()
            display()
         } else if integer(e) = (&lrelease | &rrelease | &mrelease) then {
            self.is_held := &null
            WAttrib(get_parent_win(), "pointer=" || temp_pointer)
            end_pos := set_curr_pos()
            CopyArea(temp_win, get_parent_win(), 0, 0, temp_w, temp_h, 0, 0)
            WClose(self.temp_win)
            unique_end()
            return _Event(e, self, 0)
         }
      }
   end
end


##
#  This is the parent class of the button classes, including
#  checkboxes.
#
#  A {Button} produces and {Event} of code {0} when the button is
#  depressed, and code {1} when it is released.
#
#  By default, when a button holds the keyboard focus a dashed
#  line appears just within the button.  Then, when return is
#  pressed an event of code {2} is generated.  The method
#  {_Dialog.set_initial_focus()} can be used to have the button
#  have the focus when the dialog is first displayed.
#
#  Buttons also repeatedly produce an event of -1 whilst they
#  are held down, rather like a repeating keyboard press.  The
#  delay between the initial repeat event and subsequent repeat
#  events is set in the parent dialog (see above).
#
class Button : Toggle : Component(
   is_down,
   is_held,
   is_checked_flag,
   label,
   img_up,
   img_down,
   img_w,
   img_h,
   parent_check_box_group,
   parent_button_group,
   repeat_delay,
   no_keyboard_flag,
   is_checkbox_flag
   )

   method set_parent_button_group(x)
      return self.parent_button_group := x
   end

   ##
   #  Invoking this method disables the keyboard control over the
   #  button described above.  No dashed line will ever appear in
   #  the button display and return will have no effect on the
   #  button even if it has the focus.
   #
   method set_no_keyboard()
      self.no_keyboard_flag := 1
      self.accepts_tab_focus_flag := &null
      return
   end

   method tick()
      if dispatcher$curr_time_of_day() > self.repeat_delay then
         self.parent_Component$handle_notify(_Event(EVENT_BUTTON_HELD, self, -1))
   end

   method go_down()
      self.is_down := 1
      set_ticker(self.parent_Dialog.repeat_rate)
   end

   method go_up()
      self.is_down := &null
      stop_ticker()
   end

   method handle_event(e)
      if integer(e) = (&lpress | &rpress | &mpress) then {
         if self$in_region() then {
            go_down()
            self.repeat_delay := dispatcher$curr_time_of_day() + self.parent_Dialog.repeat_delay
            self.is_held := 1
            every b := !(\self.parent_button_group).buttons do {
               if b$is_unhidden() then {
                  b.is_held := 1
                  b.repeat_delay := self.repeat_delay
               }
            }
            self$display()
            return _Event(e, self, 0)
         }
      } else if integer(e) = (&ldrag | &rdrag | &mdrag) & \self.is_held then {
         #
         # Button held down; toggle on/off as it goes over the button
         #
         if self$in_region() then {
            if /self.is_down then {
               go_down()
               display()
            }
         } else {
            if \self.is_down then {
               go_up()
               display()
            }
         }
      } else if integer(e) = (&lrelease | &rrelease | &mrelease) & \self.is_held then {
         self.is_held := &null
         if \self.is_down then {
            if \self.is_checkbox_flag then {
               if \self.parent_check_box_group then
                  self.parent_check_box_group$set_which_one(self)
               else
                  self$toggle_is_checked()
            }
            #
            # Released whilst button down; succeed
            #
            go_up()
            self$display()
            return _Event(e, self, 1)
         }
      } else if /self.no_keyboard_flag & \self.has_focus & e == ("\r" | "\l") then {
         if \self.is_checkbox_flag then {
            if \self.parent_check_box_group then
               self.parent_check_box_group$set_which_one(self)
            else
               self$toggle_is_checked()
         }
         self$display()
         return _Event(e, self, 2)
      }

      fail
   end

   ##
   #  Set the up/down images (if any) to the strings provided,
   #  which should be in Icon image format.
   #  The two images must have the same dimensions.
   #  @param x   The up image
   #  @param y   The down image
   #
   method set_imgs(x, y)
      self.img_up := x
      self.img_w := img_width(x) = img_width(y) | error("Image widths differ")
      self.img_h := img_height(x) = img_height(y) | error("Image heights differ")

      self.img_down := y

      return
   end

   ##
   #  Set the image (if any) to the given string, which should be in Icon image
   #  format.
   #  @param x   The image
   #
   method set_img(x)
      self.img_up := self.img_down := x
      self.img_w := img_width(x)
      self.img_h := img_height(x)
      return x
   end

   ##
   #  Toggle the checked status of the button.  This method, and
   #  the following two methods, may be
   #  inappropriate for non-toggle styles of button.
   #
   method toggle_is_checked()
      self$Toggle.toggle_is_checked()
      self$redisplay()
   end

   ##
   #  Set the status to checked.
   #
   method set_is_checked()
      self$Toggle.set_is_checked()
      self$redisplay()
   end

   ##
   #  Set the status to unchecked.
   #
   method clear_is_checked()
      self$Toggle.clear_is_checked()
      self$redisplay()
   end

   ##
   #  Set the label of the button, if any.
   #  @param x   The label
   #
   method set_label(x)
      self.label := x
      self$redisplay()
      return x
   end

   initially
      self$Component.initially()
      self.accepts_tab_focus_flag := 1
end

##
#  An instance of this class is a small button with a label
#  which is either in an on or off state.  The button is an
#  Icon image, which may be specified by the user if desired.
#
#  The images will default to appropriate values if not specified.
#
#  The size will also default if not specified.  The methods
#  used to control the images, label and check the status are
#  inherited from the superclasses {Button} and {Toggle}.
#  @example
#  @ c := CheckBox()
#  @ c$set_pos(200, 100)
#  @ c$set_label("Checkbox")
#  @ self$add(c)
#
class CheckBox : Button()
   method into_cbg()
      if self.img_up == img_style("box_up") & self.img_down == img_style("box_down") then
         self$set_imgs(img_style("diamond_up"), img_style("diamond_down"))
   end

   method resize()
      if /self.label then
         error("no label specified")

      if /self.h_spec := WAttrib(self.cwin, "fheight") then
         self.h_spec <:= img_h
      /self.w_spec := TextWidth(self.cwin, self.label) + 2 * self.img_w
      self$Component.resize()
   end

   method display(buffer_flag)
      local cw
      if \self.is_down then
         i := if /self.is_checked_flag then img_down else img_up
      else
         i := if \self.is_checked_flag then img_down else img_up

      #
      # Draw image and string centred vertically; image has img_w pixel
      # to its right
      #
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawImage(self.cbwin, self.x, self.y + (self.h - img_h) / 2, i)
      left_string(self.cbwin, self.x + 2 * self.img_w, self.y + self.h / 2, self.label)

      if /self.no_keyboard_flag & \self.has_focus then {
         cw := Clone(self.cbwin, "pattern=gray", "fillstyle=masked")
         DrawRaisedRectangle(cw, self.x + 2 * self.img_w, self.y,
                                 self.w - 2 * self.img_w, self.h,1)
         Uncouple(cw)
	 }

      self$do_shading(self.cbwin)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   initially
      self$Button.initially()
      self$set_imgs(img_style("box_up"), img_style("box_down"))
      self.is_checkbox_flag := 1
end

##
#  A button with a text label.
#
#  The size of the button can either be set using {set_size()},
#  be left to default to a size based on the given label.
#
class TextButton : Button(
   internal_alignment,
   tx,
   tw
   )

   ##
   #  Set the alignment of the label within the button.  The
   #  parameter should be either ``l'', ``c'' or ``r'' to set the
   #  alignment to left, centre or right respectively.  If this
   #  method is not invoked, then the alignment is centred.
   #  @param x   The alignment
   #
   method set_internal_alignment(x)
      return self.internal_alignment := x
   end

   method display(buffer_flag)
      local cw
      yoff := self.y + self.h / 2
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)

      case self.internal_alignment of {
         "c" : center_string(self.cbwin, self.tx + self.tw / 2, yoff, self.label)
         "l" : left_string(self.cbwin, self.tx, yoff, self.label)
         "r" : right_string(self.cbwin, self.tx + self.tw, yoff, self.label)
         default : error("incorrect internal_alignment specifier")
      }

      if /self.no_keyboard_flag & \self.has_focus then {
         cw := Clone(self.cbwin, "pattern=gray", "fillstyle=masked")
         DrawRaisedRectangle(cw, self.x + BORDER_WIDTH + 1, self.y + BORDER_WIDTH + 1, self.w - 2 * BORDER_WIDTH - 2, self.h - 2 * BORDER_WIDTH - 2,1)
         Uncouple(cw)
         }

      if \self.is_down then {
         cw := Clone(self.cbwin, "drawop=reverse")
         FillRectangle(cw, self.x, self.y, self.w, self.h)
         Uncouple(cw)
         DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)
      } else {
         DrawRaisedRectangle(self.cbwin, self.x, self.y, self.w, self.h,2)
         if /self.is_checked_flag then
            DrawRaisedRectangle(self.cbwin, self.x, self.y, self.w, self.h,2)
         else
            DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)
      }

      self$do_shading(self.cbwin)
      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)

      return
   end

   method resize()
      if /self.label then
         error("no label specified")
      /self.w_spec := TextWidth(self.cwin, self.label) + 2 * DEFAULT_TEXT_X_SURROUND
      /self.h_spec := WAttrib(self.cwin, "fheight") +  2 * DEFAULT_TEXT_Y_SURROUND
      self$Component.resize()

      self.tx := self.x + DEFAULT_TEXT_X_SURROUND
      self.tw := self.w - 2 *  DEFAULT_TEXT_X_SURROUND
   end

   initially
      self$Button.initially()
      self.internal_alignment := "c"
end

##
#  This is a button with an Icon image within it.
#
#  There is a useful program in the Icon program library called
#  {xpmtoims}, which will take an xpm file and output the
#  equivalent Icon image string, which can then be inserted
#  into a program.  See also the X window programs sxpm and
#  pixmap for viewing and editing xpm files respectively.
#
#  A border may be requested with {set_draw_border().}
#
#  Unless explicitly specified, the size will default to the
#  image's size, plus a standard surround if a border is
#  requested.
#  @example
#  @ Create a button with a diamond image and a border
#  @ b := IconButton()
#  @ b$toggle_draw_border()
#  @ b$set_img("11,c1,_
#  @ ~~~~~0~~~~~_
#  @ ~~~~000~~~~_
#  @ ~~0000000~~_
#  @ ~000000000~_
#  @ ~~0000000~~_
#  @ ~~~~000~~~~_
#  @ ~~~~~0~~~~~_
#  @")
#
class IconButton : Button()
   method display(buffer_flag)
      local i

      if \self.is_down then
         i := img_down
      else
         i := if \self.is_checked_flag then img_down else img_up

      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)

      DrawImage(self.cbwin, self.x + (self.w - self.img_w) / 2, self.y + (self.h - self.img_h) / 2, i)
      if \self.is_down then {
         #
         # Invert the inside of the area
         #
         cw := Clone(self.cbwin, "drawop=reverse")
         FillRectangle(cw, self.x, self.y, self.w, self.h)
         Uncouple(cw)
         DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)
      } else {
         if \self.draw_border_flag then {
            if /self.is_checked_flag then
	       DrawRaisedRectangle(self.cbwin,self.x, self.y, self.w, self.h,2)
            else
	       DrawSunkenRectangle(self.cbwin,self.x, self.y, self.w, self.h,2)
         }
      }

      if /self.no_keyboard_flag & \self.has_focus then {
          cw := Clone(self.cbwin, "pattern=gray", "fillstyle=masked")
          Rectangle(cw, self.x + BORDER_WIDTH + 1, self.y + BORDER_WIDTH + 1, self.w - 2 * BORDER_WIDTH - 2, self.h - 2 * BORDER_WIDTH - 2)
         Uncouple(cw)
      }

      self$do_shading(self.cbwin)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
      return
   end

   method resize()
      if /self.img_up | /self.img_down then
         error("no image specified")
      if \self.draw_border_flag then {
         /self.w_spec := self.img_w + 2 * DEFAULT_TEXT_X_SURROUND
         /self.h_spec := self.img_h + 2 * DEFAULT_TEXT_Y_SURROUND
      } else {
         /self.w_spec := self.img_w
         /self.h_spec := self.img_h
      }
      self$Component.resize()
   end

end

##
#  This is simply a TextButton which acts as a toggle button.
#  In other words, when it is pressed down it stays down.  When
#  it is pressed again it comes back up.  It therefore has one
#  of two states, like a check box.
#
class ToggleTextButton : TextButton()
   initially
      self$TextButton.initially()
      self.is_checkbox_flag := 1
end

##
#  The equivalent of a {ToggleTextButton}, but for an
#  {IconButton}.
#
class ToggleIconButton : IconButton()
   initially
      self$IconButton.initially()
      self.is_checkbox_flag := 1
end


##
#  This class displays an icon, supplied in Icon image format.  A
#  border may be requested with {toggle_draw_border()}.
#
#  Unless explicitly specified, the size will default to the
#  image's size, plus a standard surround if a border is
#  requested.
#
class Icon : Component(
   img,
   img_w,
   img_h
   )

   method display(buffer_flag)
      W := if /buffer_flag then self.cwin else self.cbwin
      EraseRectangle(W, self.x, self.y, self.w, self.h)

      if \self.draw_border_flag then
         DrawRaisedRectangle(W, self.x, self.y, self.w, self.h,2)

      DrawImage(W, self.x + (self.w - self.img_w) / 2, self.y + (self.h - self.img_h) / 2, self.img)

      self$do_shading(W)
      return
   end

   ##
   #  Set the image to be displayed.
   #  @param x  The image to be displayed
   #
   method set_img(x)
      self.img := x
      self.img_w := img_width(x)
      self.img_h := img_height(x)
      self$redisplay()
      return x
   end

   method resize()
      if /self.img then
         error("no image specified")
      if \self.draw_border_flag then {
         /self.w_spec := self.img_w + 2 * DEFAULT_TEXT_X_SURROUND
         /self.h_spec := self.img_h + 2 * DEFAULT_TEXT_Y_SURROUND
      } else {
         /self.w_spec := self.img_w
         /self.h_spec := self.img_h
      }
      self$Component.resize()
   end

   method handle_event(e)
      fail
   end
end

##
#  This class implements a Text label.  The default width and
#  height are determined by dimensions of text
#
class Label : Component(
   label,
   internal_alignment,
   tx,
   tw
   )

   ##
   #  The internal alignment of the label, which should be one of
   #  ``l'', ``c'' or ``r'', for left, centre, or right
   #  alignment respectively.   The default is ``l''.
   #  @param x   The alignment.
   #
   method set_internal_alignment(x)
      return self.internal_alignment := x
   end

   ##
   #  Set the label.
   #  @param x   The label.
   #
   method set_label(x)
      self.label := x
      self$redisplay()
      return x
   end

   method resize()
      if /self.label then
         error("no label specified")

      if \self.draw_border_flag then {
         /self.w_spec := TextWidth(self.cwin, label) + 2 * DEFAULT_TEXT_X_SURROUND
         /self.h_spec := WAttrib(self.cwin, "fheight") + 2 * DEFAULT_TEXT_Y_SURROUND
      } else {
         /self.w_spec := TextWidth(self.cwin, label)
         /self.h_spec := WAttrib(self.cwin, "fheight")
      }
      self$Component.resize()

      if \self.draw_border_flag then {
         self.tx := self.x + DEFAULT_TEXT_X_SURROUND
         self.tw := self.w - 2 *  DEFAULT_TEXT_X_SURROUND
      } else {
         self.tx := self.x
         self.tw := self.w
      }
   end

   method display(buffer_flag)
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)

      yoff := self.y + self.h / 2

      if \self.draw_border_flag then
         DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)

      Clip(self.cbwin, self.tx, self.y, self.tw, self.h)

      case self.internal_alignment of {
         "c" : center_string(self.cbwin, self.tx + self.tw / 2, yoff, self.label)
         "l" : left_string(self.cbwin, self.tx, yoff, self.label)
         "r" : right_string(self.cbwin, self.tx + self.tw, yoff, self.label)
         default : error("incorrect internal_alignment specifier")
      }

      Clip(self.cbwin)
      self$do_shading(self.cbwin)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   method handle_event(e)
      fail
   end

   initially
      self$Component.initially()
      self.internal_alignment := "l"
end

##
#  This class loads an image from file and displays it.  The
#  image should be in GIF format.  A border may be included
#  with {toggle_draw_border()}.
#
#  The size of the area into which the image is drawn must be
#  set with {set_size()}.
#
class Image : Component(
   filename,
   scale_up_flag,
   x_internal_alignment,
   y_internal_alignment
   )

   ##
   #  Set the horizontal and vertical alignment of the image within the
   #  area of the component; {x} should be ``l'', ``c'' or ``r'', {y} should
   #  be ``t'', ``c'' or ``b''.  Default is ``c'', ``c''.
   #
   method set_internal_alignment(x, y)
      self.x_internal_alignment := x
      self.y_internal_alignment := y
      return
   end

   ##
   #  Set the name of the file from which to load the image;
   #  re-display the image from the new file if appropriate.
   #
   method set_filename(x)
      self.filename := x
      self$redisplay()
      return x
   end

   ##
   #  If set, then the image will be scaled up to fit in the space
   #  specified by {set_size()}.  The image will not be distorted,
   #  but will be expanded to fill one of the dimensions depending
   #  on its shape.  If the image is bigger than the specified size
   #  then it will always be scaled down.
   #
   method set_scale_up()
      return self.scale_up_flag := 1
   end

   method display(buffer_flag)
      local imwin
      W := if /buffer_flag then self.cwin else self.cbwin

      EraseRectangle(W, self.x, self.y, self.w, self.h)

      #
      # Compute borders; smaller if border needed.
      #
      if \self.draw_border_flag then {
         x1 := self.x + BORDER_WIDTH
         y1 := self.y + BORDER_WIDTH
         w1 := self.w - 2 * BORDER_WIDTH
         h1 := self.h - 2 * BORDER_WIDTH
      } else {
         x1 := self.x
         y1 := self.y
         w1 := self.w
         h1 := self.h
      }

      #
      # Load the image
      #
      if not(imwin := WOpen("image=" || \self.filename, "canvas=hidden")) then
         fail
#
#      Uncomment the following lines if you're multiple images are using
#      more than 256 colors and aren't showing properly on X11 systems.
#
#      EraseArea(imwin)
#      ReadImage(imwin, self.filename, 0, 0, "c6")
      #
      # Scale the image to the desired size
      #
      img_w := WAttrib(imwin, "width")
      img_h := WAttrib(imwin, "height")
      aspr := real(img_w) / real(img_h)
      aspmax := real(w1) / real(h1)

      if /self.scale_up_flag & (img_w <= w1) & (img_h <= h1) then {
         zoom_w := img_w
         zoom_h := img_h
      } else {
         if aspr > aspmax then {
            zoom_w := w1
            zoom_h := integer(w1 / aspr)
         } else {
            zoom_w := integer(h1 * aspr)
            zoom_h := h1
         }
      }

      #
      # Adjust within region as per internal_alignment
      #
      case self.y_internal_alignment of {
         "t" : yoff := 0
         "b" : yoff := h1 - zoom_h
         "c" : yoff := (h1 - zoom_h) / 2
         default : error("incorrect y internal_alignment specifier")
      }

      case self.x_internal_alignment of {
         "l" : xoff := 0
         "r" : xoff := w1 - zoom_w
         "c" : xoff := (w1 - zoom_w) / 2
         default : error("incorrect x internal_alignment specifier")
      }

      zoom_w <:= 1
      zoom_h <:= 1

      #
      # Transform and copy image to window.
      #
      Zoom(imwin, W, 0, 0, img_w, img_h, x1 + xoff, y1 + yoff, zoom_w, zoom_h)
      WClose(imwin)

      #
      # Border if required.
      #
      if \self.draw_border_flag then
         DrawRaisedRectangle(W, x1 + xoff - BORDER_WIDTH, y1 + yoff - BORDER_WIDTH, zoom_w + 2 * BORDER_WIDTH, zoom_h + 2 * BORDER_WIDTH,2)
      self$do_shading(W)

   end

   method handle_event(e)
      fail
   end

   initially
      self$Component.initially()
      self.x_internal_alignment := self.y_internal_alignment := "c"
end

##
#  A class for a single input line of text.  The text can
#  scroll within the area specified.  By default, a border
#  surrounds the text area; this can be turned of by using
#  {toggle_draw_border()}.
#
#  The horizontal size must be set by the {set_size()} method:
#  there is no default (the vertical size will default, however).
#
#  An event is generated when return is pressed (with code 0),
#  and whenever the contents are changed (with code 1).
#
#  @example
#  @ t := TextField()
#  @ t$set_pos(50, 250)
#  @ # Vertical size will default
#  @ t$set_size(100)
#  @ t$set_contents("Initial string")
#  @ self$add(t)
#
class TextField : Component(
   filter,                  # Cset for filtering characters
   printable,               # The printable characters
   contents,
   cursor,
   leftmost,
   rightmost,
   tx,
   tw,
   displaychar              # char to print on screen
   )

   method set_displaychar(c)
      displaychar := c
   end

   ##
   #  Set a filter on the characters allowed to be input to the text field.
   #  @param c  The cset of permissible characters.
   #  @example
   #  @ # Permit only hexadecimal characters as input
   #  @ set_filter('0987654321abcdefABCDEF')
   #
   method set_filter(c)
      return self.filter := c ** printable
   end

   ##
   #  Return the present contents of the text field.
   #
   method get_contents()
      return self.contents
   end

   method resize()
      if \self.draw_border_flag then
         /self.h_spec := WAttrib(self.cwin, "fheight") + 2 * DEFAULT_TEXT_Y_SURROUND
      else
         /self.h_spec := WAttrib(self.cwin, "fheight")
      self$Component.resize()

      if \self.draw_border_flag then {
         self.tx := self.x + DEFAULT_TEXT_X_SURROUND
         self.tw := self.w - 2 *  DEFAULT_TEXT_X_SURROUND
      } else {
         #
         # Still want an offset for the text so that a click slightly to the left of
         # the text itself is recognised.  Therefore, just have a slightly smaller surround.
         #
         self.tx := self.x + (DEFAULT_TEXT_X_SURROUND - BORDER_WIDTH)
         self.tw := self.w - 2 * (DEFAULT_TEXT_X_SURROUND - BORDER_WIDTH)
      }
   end

   ##
   #  Set the contents of the field.  If not invoked then
   #  the initial content is the empty string.
   #  @param x   The contents
   #
   method set_contents(x)
      self.contents := string(x)
      self.cursor := *self.contents + 1
      self.leftmost := 1
      self$redisplay()
      return x
   end

   #
   # Mouse click - compute new cursor position, re-display
   #
   method handle_press()
      #
      # Space at end for cursor at end of string
      #
      s := self.contents || " "

      startx := self.tx

      self.cursor := self.leftmost
      while (startx + TextWidth(self.cwin, s[self.leftmost:self.cursor + 1]) <= &x) & (self.cursor + 1 < self.rightmost) do
         self.cursor +:= 1

      self$display()
   end

   #
   # Delete
   #
   method handle_delete1()
      if self.cursor > 1 then {
         self.contents[self.cursor - 1] := ""
         self.cursor -:= 1
         self$display()
         return _Event(e, self, 1)
      }
   end

   method handle_return(e)
      return _Event(e, self, 0)
   end

   method handle_key_right(e)
      self.cursor := (*self.contents + 1 >= self.cursor + 1)
      self$display()
   end

   method handle_key_left(e)
      self.cursor := (0 < self.cursor - 1)
      self$display()
   end

   method handle_delete_line(e)
      self.contents := ""
      self.cursor := 1
      self$display()
      return _Event(e, self, 1)
   end

   method handle_delete_2(e)
      if self.cursor <= *self.contents then {
         self.contents[self.cursor] := ""
         self$display()
         return _Event(e, self, 1)
      }
   end

   method handle_start_of_line(e)
      self.cursor := 1
      self$display()
   end

   method handle_end_of_line(e)
      self.cursor := *self.contents + 1
      self$display()
   end

   method handle_default(e)
      #
      # Add any printable character at cursor position, and return
      # event with code 1.
      #
      if type(e) == "string" & not(&control | &meta) & any(filter, e) then {
         if self.cursor = 1 then
            self.contents := e || self.contents
         else
            self.contents[self.cursor - 1] ||:= e
         self.cursor +:= 1
         self$display()
         return _Event(e, self, 1)
      }
   end

   method handle_event(e)
      local code

      return if self$in_region() & (integer(e) = (&lpress | &rpress | &mpress)) then
         handle_press(e)
      else if \self.has_focus then {
         #
         # Object has focus.  Handle various key presses.
         #
         case e of {
            "\b" : handle_delete1(e)
            "\r" | "\l": handle_return(e)
            "\^k" : handle_delete_line(e)
            Key_Right : handle_key_right(e)
            Key_Left : handle_key_left(e)
            "\^a" : handle_start_of_line(e)
            "\^e" : handle_end_of_line(e)
            "\d" | "\^d" : handle_delete_2(e)
            default : handle_default(e)
         }
      }
   end

   method display(buffer_flag)
      local r

      fh := WAttrib(self.cwin, "fheight")

      spc := self.tw

      #
      # Space at end for cursor at end of string
      #
      if \displaychar then
         s := repl("*", *(self.contents)) || " "
      else
         s := self.contents || " "

      #
      # Initialize left and right markers; only move leftmost if needed
      #
      self.leftmost >:= self.cursor
      self.rightmost := self.cursor + 1

      #
      # Now pad out left and right markers to fill space
      #
      if TextWidth(self.cwin, s[self.leftmost:self.rightmost]) <= spc then {
         while TextWidth(self.cwin, s[self.leftmost:self.rightmost + 1]) <= spc do
            self.rightmost +:= 1
      } else {
         while TextWidth(self.cwin, s[self.leftmost:self.rightmost]) > spc do
            self.leftmost +:= 1
      }

      #
      # Clear rectangle, set s to string to display
      #
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      s := s[self.leftmost:self.rightmost]

      #
      # Cursor position within s
      #
      cp := self.cursor - self.leftmost + 1

      if \self.draw_border_flag then
         DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)

      #
      # Display s centred vertically in box
      #
      left_string(self.cbwin, self.tx, self.y + self.h / 2 , s)

      #
      # If has focus display box cursor, else display outline cursor
      #
      if \self.has_focus then {
         FillRectangle(self.cbwin, self.tx + TextWidth(self.cwin, s[1:cp]), 1 + self.y + (self.h - fh) / 2, TextWidth(self.cwin, s[cp]), fh)
         cw := Clone(self.cbwin, "drawop=reverse")
         left_string(cw, self.tx + TextWidth(cw, s[1:cp]), self.y + self.h / 2 , s[cp])
         Uncouple(cw)
      } else
         Rectangle(self.cbwin, self.tx + TextWidth(self.cwin, s[1:cp]), 1 + self.y + (self.h - fh) / 2, TextWidth(self.cwin, s[cp]), fh)

      self$do_shading(self.cbwin)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   initially
      self$Component.initially()
      filter := printable := cset(&ascii[33:128])
      self.accepts_tab_focus_flag := 1
      self$set_contents("")
      self.draw_border_flag := 1
end

##
#  This class provides decorative borders.  Optionally, a
#  single other component can be the title of the Border.  This
#  would normally be a Label object, but it could also be a
#  CheckBox or an Icon, or whatever is desired.
#
#  @example
#  @ b := Border()
#  @
#  @ # Add a Label as the title
#  @
#  @ l := Label()
#  @ l$set_label("Title String")
#  @ b$set_title(l)
#  @ self$add(b)
#
class Border : Panel(
   internal_alignment,
   title_obj,
   y1,
   h1
   )

   ##
   #  Set the alignment of the title object.  The input string should be
   #  ``l'', ``c'' or ``r''.
   #
   method set_internal_alignment(x)
      return self.internal_alignment := x
   end

   ##
   #  Set the title object to c.
   #
   method set_title(c)
      title_obj := c
      add(c)
   end

   method display(buffer_flag)
      W := if /buffer_flag then self.cwin else self.cbwin

      DrawSunkenRectangle(W, self.x, y1, self.w, h1,-1)
      DrawRaisedRectangle(W, self.x + BORDER_WIDTH, y1 + BORDER_WIDTH, self.w - 2 * BORDER_WIDTH, h1 - 2 * BORDER_WIDTH,1)

      if \title_obj then {
         case self.internal_alignment of {
            "c" : EraseRectangle(W, self.x + self.w / 2 - title_obj.w / 2 - BORDER_TEXT_SPACING, y1, title_obj.w + 2 * BORDER_TEXT_SPACING, 2 * BORDER_WIDTH)
            "l" : EraseRectangle(W, self.x + DEFAULT_TEXT_X_SURROUND, y1, title_obj.w + 2 * BORDER_TEXT_SPACING, 2 * BORDER_WIDTH)
            "r" : EraseRectangle(W, self.x + self.w - title_obj.w - DEFAULT_TEXT_X_SURROUND - 2 * BORDER_TEXT_SPACING, y1, title_obj.w + 2 * BORDER_TEXT_SPACING, 2 * BORDER_WIDTH)
         }
      }

      every (!self.components)$display(buffer_flag)
      self$do_shading(W)
   end

   method get_y_reference()
      return self.y1
   end

   method get_h_reference()
      return self.h1
   end

   method resize()
      self$Component.resize()
      y1 := self.y
      h1 := self.h
      if \title_obj then {
         title_obj$set_align(self.internal_alignment, "c")
         case self.internal_alignment of {
            "c" : title_obj$set_pos("50%", 0)
            "l" : title_obj$set_pos(DEFAULT_TEXT_X_SURROUND + BORDER_TEXT_SPACING, 0)
            "r" : title_obj$set_pos("100%-" || (DEFAULT_TEXT_X_SURROUND + BORDER_TEXT_SPACING), 0)
            default : error("incorrect internal_alignment specifier")
         }
         #
         # Resize title_obj to work out y1, h1; note that title_obj will be resized again below
         # using the new y1, h1.
         #
         title_obj$resize()
         y1 := self.y + title_obj.h / 2
         h1 := self.h - title_obj.h / 2
      }
      every (!self.components)$resize()
   end

   initially
      self$Panel.initially()
      self.internal_alignment := "l"
end


##
#  This class is simply a container for several objects
#  which then act together as ``radio buttons''.  The objects
#  should be subclasses of {Toggle}, but are normally checkboxes.
#
#  The set/unset status of objects in a {CheckBoxGroup} should be set
#  with the {set_which_one} method, not by setting the individual items
#  directly with their own methods; that would result in confusion.
#
#  NB - the objects in the group must be added to both the {CheckBoxGroup}
#  and the dialog box too; a {CheckBoxGroup} is not a {Container}.
#
class CheckBoxGroup(
   checkboxes,
   which_one
   )

   ##
   #  Set the object which is down according to the integer i.
   #  If i = 1 then the first object is down, if i = 2 the
   #  second is down, etc for i = 4, 8, 16.
   #
   method set_by_flag(i)
      j := 1
      every c := !checkboxes do {
         if i = j then {
            self$set_which_one(c)
            break
         }
         j *:= 2
      }
   end

   ##
   #  Returns an integer in the range 1, 2, 4, 8 ... depending
   #  upon whether the first, second, third etc object is down.
   #
   method get_by_flag()
      i := 1
      every c := !checkboxes do {
         if c === self.which_one then
            return i
         i *:= 2
      }
      return 0
   end

   ##
   #  Returns the object is currently down.
   #
   method get_which_one()
      return self.which_one
   end

   ##
   #  Add the object to the CheckBoxGroup.
   #  @param c   The object to add, which must be a subclass of {Toggle}.
   #
   method add(c)
      put(self.checkboxes, c)
      c$set_parent_check_box_group(self)
      c$into_cbg()
   end

   ##
   #  Set which CheckBox which is down.
   #  @param x   The object which is down.
   #
   method set_which_one(x)
      (\self.which_one)$toggle_is_checked()
      x$toggle_is_checked()
      return self.which_one := x
   end

   initially
      self.checkboxes := []
end

$define MIN_BAR_SIZE 8

##
#  This class provides horizontal and vertical scroll bars.
#
#  There are two ways to use a scroll bar.  The first way is to
#  set a total_size (represented by the whole bar), a page_size
#  (represented by the draggable button) and an increment_size
#  (being the amount added/subtracted when the top/bottom
#  button is pressed).  The value will then range from zero to
#  (total_size - page_size) inclusive.  An initial value must
#  be set with the {set_value()} method.
#  @example
#  @ vb := ScrollBar()
#  @ vb$set_pos("85%", "25%")
#  @ vb$set_size(20, "40%")
#  @ vb$set_total_size(130)
#  @ vb$set_page_size(30)
#  @ vb$set_increment_size(1)
#  @ vb$set_value(0)
#  @ self$add(vb)
#
#  Alternatively, a scroll bar can be used as a slider which
#  ranges over a given range of values.  In this case, the
#  range is set with {set_range()}.  It is still necessary to set
#  the increment size and the initial value, as above, but
#  page_size and total_size should not be set.
#
#  Real numbers as opposed to integers can be used for the
#  range settings if desired.
#  @example
#  @ vb := ScrollBar()
#  @ vb$set_pos("85%", "25%")
#  @ vb$set_size(20, "40%")
#  @ vb$set_range(2, 25)
#  @ vb$set_value(10)
#  @ vb$set_increment_size(1)
#  @ self$add(vb)
#
#  An Event is returned whenever the buttons are pressed or the
#  bar dragged; the value can be retrieved by get_value().  The
#  event code (obtainable by {get_code()}) is 1 if the bar has
#  been dragged, and 0 if either button has been pressed or the
#  bar released after being dragged.  This fact can be used to
#  reduce the number of events which are processed by the
#  user's program - just ignore events with code 1.
#
class ScrollBar : Component(
   value,
   page_size,
   increment_size,
   total_size,
   hi,
   lo,
   bar_area_x,
   bar_area_y,
   bar_area_w,
   bar_area_h,
   bar_x,
   bar_y,
   bar_w,
   bar_h,
   bar_down,
   bar_down_offset,
   b1,
   b2,
   is_horizontal_flag,
   bar_pos,
   bar_size,
   bar_area_pos,
   bar_area_size,
   is_range_flag
   )

   method final_setup(x, y)
      self$Component.final_setup(x, y)
      self.b1$final_setup(x, self)
      self.b2$final_setup(x, self)
   end

   ##
   #  Make the scroll bar horizontal (default is vertical).
   #
   method set_is_horizontal()
      return self.is_horizontal_flag := 1
   end

   ##
   #  Set the total size which the scroll bar area represents.
   #  @param x   The total size
   #
   method set_total_size(x)
      return self.total_size := x
   end

   ##
   #  Return the total size.
   #
   method get_total_size()
      return self.total_size
   end

   ##
   #  Set the size which the bar in the scroll bar area represents.
   #  @param x   The size.
   #
   method set_page_size(x)
      return self.page_size := x
   end

   ##
   #  Get the page size.
   #
   method get_page_size()
      return self.page_size
   end

   ##
   #  Get the value.
   #  @return The value
   #
   method get_value()
      return self.value
   end

   ##
   #  Set the value representing the top of the bar in the scroll
   #  bar.  The value is forced into range if it is not in range already.
   #  @param x   The value.
   #
   method set_value(x)
      if \(\self.parent_Dialog).is_open then {
         self$move_value(x)
         self$set_pos_from_value()
         self$refresh()
      } else
         self.value := x
      return x
   end

   ##
   #  Set the amount to increase the value by when one of the
   #  buttons is pressed.
   #  @param x   The increment size.
   #
   method set_increment_size(x)
      return self.increment_size := x
   end

   ##
   #  Set the range of the scroll bar.  The values may
   #  be integer or real.
   #  @param lo  The lower bound
   #  @param hi  The upper bound
   #
   method set_range(lo, hi)
      self.is_range_flag := 1
      self.lo := lo
      self.hi := hi
   end

   method firstly()
      self$Component.firstly()
      self.b1$firstly()
      self.b2$firstly()
   end

   method finally()
      self$Component.finally()
      b1$finally()
      b2$finally()
   end

   method move_bar_pos(x)
      self.bar_pos := x
      self.bar_pos <:= self.bar_area_pos
      self.bar_pos >:= self.bar_area_pos + self.bar_area_size - self.bar_size
      if /self.is_horizontal_flag then
         self.bar_y := self.bar_pos
      else
         self.bar_x := self.bar_pos
   end

   method move_value(x)
      self.value := x
      self.value <:= self.lo
      self.value >:= self.hi
   end

   method set_pos_from_value()
      if self.hi ~= self.lo then
         self$move_bar_pos(self.bar_area_pos + integer(((self$get_value() - self.lo) * (self.bar_area_size - self.bar_size)) / (self.hi - self.lo)))
      else
         self$move_bar_pos(self.bar_area_pos)
   end

   method set_value_from_pos()
      if self.bar_area_size ~= self.bar_size then
         self$move_value(self.lo + ((self.hi - self.lo) * (self.bar_pos - self.bar_area_pos)) / (self.bar_area_size - self.bar_size))
      else
         self$move_value(self.lo)
   end

   method handle_notify(e)
      if e$get_component() === b1 then {
         #
         # Button up clicked
         #
         self$move_value(self$get_value() - self.increment_size)
         self$set_pos_from_value()
      } else if e$get_component() === b2 then {
         #
         # Button down clicked
         #
         self$move_value(self$get_value() + self.increment_size)
         self$set_pos_from_value()
      }
      #
      # Re-draw bar
      #
      self$refresh()
      self.parent_Component$handle_notify(_Event(EVENT_SCROLLED, self, 2))
   end

   method handle_event(e)
      if b1$handle_event(e)$get_code() = 0 then {
         #
         # Button up clicked
         #
         self$move_value(self$get_value() - self.increment_size)
         self$set_pos_from_value()
      } else if b2$handle_event(e)$get_code() = 0 then {
         #
         # Button down clicked
         #
         self$move_value(self$get_value() + self.increment_size)
         self$set_pos_from_value()
      }
      else if integer(e) = (&lpress | &rpress | &mpress) & (self.bar_x <= &x < self.bar_x + self.bar_w) & (self.bar_y  <= &y < self.bar_y + self.bar_h) then {
         #
         # Click on bar; set flag and save offset between top of bar and pointer position
         #
         self.bar_down := 1
         if /self.is_horizontal_flag then
            self.bar_down_offset := &y - self.bar_y
         else
            self.bar_down_offset := &x - self.bar_x
      } else if \self.bar_down & (integer(e) = (&lrelease | &rrelease | &mrelease)) then {
         #
         # Released; clear flag
         #
         self.bar_down := &null
      } else if \self.bar_down & (integer(e) = (&ldrag | &rdrag | &mdrag)) then {
         #
         # Bar dragged; compute new position
         #
         if /self.is_horizontal_flag then
            self$move_bar_pos(&y - self.bar_down_offset)
         else
            self$move_bar_pos(&x - self.bar_down_offset)
         self$set_value_from_pos()
      } else
         fail

      #
      # Re-draw bar
      #
      self$refresh()
      return _Event(e, self, \self.bar_down | 0)
   end

   method display(buffer_flag)
      W := if /buffer_flag then self.cwin else self.cbwin

      EraseRectangle(W, self.x, self.y, self.w, self.h)

      #
      # Draw rectangle around area within which bar moves
      #
      if /self.is_horizontal_flag then
         DrawRaisedRectangle(W, self.x, self.y + self.w, self.w, self.h - 2 * self.w,2)
      else
         DrawRaisedRectangle(W, self.x + self.h, self.y, self.w - 2 * self.h, self.h,2)

      #
      # Display two buttons
      #
      b1$display(buffer_flag)
      b2$display(buffer_flag)

      self$bar_to_win(W)
      self$do_shading(W)
   end

   method refresh()
      self$bar_to_win(self.cbwin)
      self$do_shading(self.cbwin)
      CopyArea(self.cbwin, self.cwin, self.bar_area_x, self.bar_area_y, self.bar_area_w, self.bar_area_h, self.bar_area_x, self.bar_area_y)
   end

   method bar_to_win(W)
      EraseRectangle(W, self.bar_area_x, self.bar_area_y, self.bar_area_w, self.bar_area_h)
      DrawRaisedRectangle(W, self.bar_x, self.bar_y, self.bar_w, self.bar_h,2)
   end

   method resize()
      self$Component.resize()

      if /self.is_range_flag then {
         #
         # Check total size and page size
         #
         if /self.total_size then
            error("total size not set")
         if /self.page_size then
            error("page size not set")
         if self.page_size <= 0 then
            error("invalid page size")
      } else {
         if \self.lo >= \self.hi then
            error("invalid range")
      }

      #
      # Check increment size, value
      #
      if /self.increment_size then
         error("increment size not set")
      if /self.value then
         error("value not set")

      if /self.is_horizontal_flag then {
         #
         # Compute bar area dimensions
         #
         self.bar_x := self.bar_area_x := self.x + BORDER_WIDTH + 2
         self.bar_area_pos := self.bar_area_y := self.y + self.w + BORDER_WIDTH + 2
         self.bar_w := self.bar_area_w := self.w - 2 * (BORDER_WIDTH + 2)
         self.bar_area_size := self.bar_area_h := self.h - 2 * self.w  - 2 * (BORDER_WIDTH + 2)

         #
         # Set button positions
         #
         b1$set_pos(0, 0)
         b1$set_size(self.w, self.w)
         b2$set_pos(0, self.h - self.w)
         b2$set_size(self.w, self.w)
         b1$set_img(img_style("arrow_up"))
         b2$set_img(img_style("arrow_down"))
      } else {
         self.bar_area_pos := self.bar_area_x := self.x + self.h + BORDER_WIDTH + 2
         self.bar_y := self.bar_area_y := self.y + BORDER_WIDTH + 2
         self.bar_area_size := self.bar_area_w := self.w - 2 * self. h - 2 * (BORDER_WIDTH + 2)
         self.bar_h := self.bar_area_h := self.h - 2 * (BORDER_WIDTH + 2)

         b1$set_pos(0, 0)
         b1$set_size(self.h, self.h)
         b2$set_pos(self.w - self.h, 0)
         b2$set_size(self.h, self.h)
         b1$set_img(img_style("arrow_left"))
         b2$set_img(img_style("arrow_right"))
      }

      if /self.is_range_flag then {
         #
         # Not a range; compute lo, hi and bar_size.
         #
         self.lo := 0
         if self.total_size > self.page_size then {
            self.hi := self.total_size - self.page_size
            self.bar_size := integer((self.bar_area_size * self.page_size) / self.total_size)
         } else {
            #
            # Total <= page; these settings produce an immovable full size bar.
            #
            self.hi := 0
            self.bar_size := self.bar_area_size
         }
      } else {
         #
         # Range; set bar size proportional to button size, but leave room if bar_area_size is small.
         #
         self.bar_size := (b1.w_spec * 3) / 2
         self.bar_size >:= self.bar_area_size - 8
      }
      #
      # Ensure bar size in range not less than MIN_BAR_SIZE, but must be within
      # bar_area_size.
      #
      self.bar_size <:= MIN_BAR_SIZE
      self.bar_size >:= self.bar_area_size

      #
      # Set bar height/width according to orientation
      #
      if /self.is_horizontal_flag then
         self.bar_h := self.bar_size
      else
         self.bar_w := self.bar_size

      b1$resize()
      b2$resize()
      self$move_value(self.value)
      self$set_pos_from_value()

      return
   end

   initially
      self$Component.initially()
      self.b1 := IconButton()
      self.b1$toggle_draw_border()
      self.b2 := IconButton()
      self.b2$toggle_draw_border()
end

$define TX_PADDING (DEFAULT_TEXT_X_SURROUND + 3)
$define TY_PADDING (DEFAULT_TEXT_Y_SURROUND + 3)

##
#  This class acts as a superclass for any object which wishes
#  to display several items within a scrollable area.
#
class ScrollArea : Component(
   contents,
   rev,                     # Cloned reverse field window
   max_width,
   tx,
   ty,
   tw,
   th,
   hsb,
   vsb,
   last_refresh_x,
   last_refresh_y,
   line_height,
   checked,
   select_one,
   select_many,
   which_down,
   going_up,
   prev_down,
   is_held,
   tab_line
   )

   ##
   #  Set the data to be displayed.
   #  @param x  The list of data.
   #
   method set_contents(x)
      self.contents := x
      #
      # Expand/contract list if necessary
      #
      while *self.checked < *x do put(self.checked)
      while *self.checked > *x do pull(self.checked)

      compute_and_redisplay()
      return x
   end

   ##
   #  Set the checked (highlighted) lines.
   #  @param l   A list.  Each element in the list corresponds to an element in
   #  @ the data.  If the element is not {&null}, the line is checked.
   #
   method set_checked(l)
      return self.checked := l
   end

   ##
   #  Get the checked lines.
   #  @return A list corresponding to the data.  If an element is not {&null}, then
   #  @ the corresponding line is checked.
   #
   method get_checked()
      return self.checked
   end

   ##
   #  Clear the checked selections.
   #
   method clear_selections()
      self.checked := list(*contents)
      redisplay()
      return
   end

   ##
   # Configure the object so that only one line may be highlighted
   #
   method set_select_one()
      self.select_one := 1
   end

   ##
   # Configure the object so that several lines may be highlighted
   #
   method set_select_many()
      self.select_many := 1
   end

   ##
   # Return item currently under the clicked cursor
   # @return The item number
   #
   method get_which_down()
      return \self.which_down
   end

   ##
   # Return object currently under the clicked cursor
   # @return The object
   #
   method object_get_which_down()
      return self.contents[\self.which_down]
   end

   ##
   # Return the item previously under the clicked cursor
   # @return The item number
   #
   method get_prev_down()
      return \self.prev_down
   end

   ##
   # Return object currently under the clicked cursor
   # @return The object
   #
   method object_get_prev_down()
      return self.contents[\self.prev_down]
   end

   ##
   #  Return a list of items checked (highlighted)
   #  @return A list of items currently checked
   #
   method get_selections()
      r := []
      every i := 1 to *self.checked do
         if \self.checked[i] then
            put(r, i)
      return r
   end

   ##
   #  Return a list of objects checked (highlighted)
   #  @return A list of objects currently checked
   #
   method object_get_selections()
      r := []
      every i := 1 to *self.checked do
         if \self.checked[i] then
            put(r, self.contents[i])
      return r
   end

   ##
   #  Set the current selections to the list l, which is a list of
   #  item numbers.
   #  @param l   The list of item numbers.
   #
   method set_selections(l)
      self.checked := list(*self.contents)
      every self.checked[!l] := 1
      redisplay()
   end

   ##
   #  Set the current selections to the list l, which is a list of objects
   #  @param l  The list of objects.
   #
   method object_set_selections(l)
      self.checked := []
      every e := !self.contents do
         put(self.checked, if e === !l then 1 else &null)
      redisplay()
   end

   ##
   #  Return the contents of the {ScrollArea}
   #
   method get_contents()
      return self.contents
   end

   method finally()
      self$Component.finally()
      (\self.vsb)$finally()
      (\self.hsb)$finally()
      self.vsb := self.hsb := &null
   end

   method handle_key_page_up(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i - self.vsb.page_size)
         self$refresh()
      }
   end

   method handle_key_page_down(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i + self.vsb.page_size)
         self$refresh()
      }
   end

   method handle_key_up(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i - 1)
         self$refresh()
      }
   end

   method handle_key_down(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i + 1)
         self$refresh()
      }
   end

   method handle_key_left(e)
      if i := (\self.hsb)$get_value() then {
         self.hsb$set_value(i - self.hsb.increment_size)
         self$refresh()
      }
   end

   method handle_key_right(e)
      if i := (\self.hsb)$get_value() then {
         self.hsb$set_value(i + self.hsb.increment_size)
         self$refresh()
      }
   end

   method handle_key_home(e)
      if (\self.vsb)$set_value(0) then
         self$refresh()
   end

   method handle_key_end(e)
      if (\self.vsb)$set_value(*self.contents - 1) then
         self$refresh()
   end

   method handle_notify(e)
      if e$get_component() === (\self.vsb | \self.hsb) then
         self$refresh()
   end

   method handle_press(e)
      if \ (self.select_one | self.select_many) & (self.tx <= &x < self.tx + self.tw) & (self.ty  <= &y < self.ty + self.th) then {
         #
         # Compute line clicked
         #
         l := (&y - self.ty) / self.line_height + self$get_line()

         if self.which_down := (self$get_last_line() >= l) then {
            if \self.select_many & (&shift | &control) then {
               #
               # Click with shift/ctrl - the state will end here.
               #
               if &control then
                  self.checked[self.which_down] := if /self.checked[self.which_down] then 1 else &null
               else {
                  #
                  # &shift
                  #
                  if \self.prev_down then {
                     if self.prev_down > self.which_down then
                        every self.checked[self.which_down to self.prev_down] := 1
                     else
                        every self.checked[self.prev_down to self.which_down] := 1
                  } else
                     self.checked[self.which_down] := 1
               }
               self.prev_down := self.which_down
               self.which_down := &null
               self$refresh(1)
               return _Event(e, self, 1)
            } else {
               #
               # Normal click down
               #
               self.is_held := 1
               self.checked := list(*self.contents)
               self$refresh(1)
               return _Event(e, self, 0)
            }
         }
      }
   end

   method end_state()
      if \self.is_held then {
         self.is_held := &null
         stop_ticker()
         #
         # Clear flag, refresh, return event
         #
         self.checked := list(*self.contents)
         self.checked[self.which_down] := 1
         self.which_down := &null
         self.prev_down := self.which_down
         self$refresh(1)
      }
   end

   method handle_drag(e)
      local old_down, l

      if \self.is_held then {
         #
         # Mouse drag - save present marked line
         #
         old_down := self.which_down

         #
         # Test for &null which down just to satisfy the drop down list
         # classes which set is_held manually.  In normal use, which_down
         # is never &null.
         #
         if &y < self.ty then {
            self.going_up := 1
            if \self.which_down & /self.ticker_rate then
               set_ticker(self.parent_Dialog.repeat_rate)
         } else if &y > self.ty + self.th then {
            self.going_up := &null
            if \self.which_down & /self.ticker_rate then
               set_ticker(self.parent_Dialog.repeat_rate)
         } else {
            l := (&y - self.ty) / self.line_height + self$get_line()
            l >:= self$get_last_line()
            self.which_down := l
            stop_ticker()
         }

         #
         # Refresh if line changed
         #
         if old_down ~=== self.which_down then
            self$refresh(1)
      }
   end

   method tick()
      if \going_up then {
         self.which_down := self$get_line() - 1
         self.which_down <:= 1
         (\self.vsb)$set_value(self.vsb$get_value() - 1)
      } else {
         self.which_down := self$get_last_line() + 1
         self.which_down >:= *self.contents
         (\self.vsb)$set_value(self.vsb$get_value() + 1)
      }
      self$refresh(1)
   end

   method handle_release(e)
      if \self.is_held then {
         #
         # Mouse released after being held down.  Clear flag
         #
         self.is_held := &null
         stop_ticker()
         #
         # Clear flag, refresh, return event
         #
         self.checked := list(*self.contents)
         self.checked[\self.which_down] := 1
         self.prev_down := self.which_down
         self.which_down := &null
         self$refresh(1)
         return _Event(e, self, 1)
      }
   end

   method handle_event(e)
      if E := (\self.vsb)$handle_event(e) then {
         #
         # Handled by VSB; amend line number and refresh contents
         #
         self$refresh()
      } else if E := (\self.hsb)$handle_event(e) then {
         #
         # Handled by HSB; amend left offset and refresh
         #
         self$refresh()
      } else if integer(e) = (&lpress | &rpress | &mpress) then
         return handle_press(e)
      else if integer(e) = (&ldrag | &rdrag | &mdrag) then
         return handle_drag(e)
      else if integer(e) = (&lrelease | &rrelease | &mrelease) then
         return handle_release(e)
      else if \self.has_focus then {
         case e of {
            Key_Home : handle_key_home(e)
            Key_End : handle_key_end(e)
            Key_PgUp : handle_key_page_up(e)
            Key_PgDn : handle_key_page_down(e)
            Key_Up : handle_key_up(e)
            Key_Down : handle_key_down(e)
            Key_Left : handle_key_left(e)
            Key_Right : handle_key_right(e)
         }
      }
   end

   method get_left_pos()
      return (self.tx - (\self.hsb)$get_value()) | self.tx
   end

   method get_line()
      return  ((\self.vsb)$get_value() + 1) | 1
   end

   method get_last_line()
      nlines := (\self.vsb)$get_page_size() | *self.contents
      return self$get_line() + nlines - 1
   end

   #
   # Present page size
   #
   method get_page_size()
      return (\self.vsb)$get_page_size() | *self.contents
   end

   #
   # Goto line, pos
   #
   method goto_pos(x, y)
      (\self.vsb)$set_value(\x - 1)
      (\self.hsb)$set_value(\y)
      self$redisplay()
   end

   method compute_and_redisplay()
      if \ (\self.parent_Dialog).is_open then
         self$set_internal_fields()
      self$redisplay()
   end

   method resize()
      self$Component.resize()
      self$set_internal_fields()
   end

   method get_line_height()
      return WAttrib(self.cwin, "fheight")
   end

   method get_max_width()
      mw := 0
      every s := !self.contents do
         mw <:= TextWidth(self.cwin, s)
      return mw
   end

   #
   # Called on resize, buttons resized, or contents amended
   #
   method set_internal_fields()
      self.line_height := get_line_height()

      #
      # Top left of text region
      #
      self.tx := self.x + TX_PADDING
      self.ty := self.y + TY_PADDING

      #
      # Initialize left_pos field, clear optimizing flags used
      # in display.
      #
      self.last_refresh_x := self.last_refresh_y := &null

      #
      # Compute maximum width
      #
      self.max_width := get_max_width()

      #
      # Compute max/min heights/widths for text; max if no scroll bar
      # needed; min otherwise.
      #
      max_th := self.h - 2 * TY_PADDING
      max_tw := self.w - 2 * TX_PADDING
      min_th := max_th - SB_SIZE
      min_tw := max_tw - SB_SIZE

      #
      # Set flags indicating whether scroll bars needed.  0 => definitely not
      # 1 => yes if opposite scroll bar needed; 2 => definitely yes.
      #
      if min_th / self.line_height >= *self.contents then
         need_vsb := 0
      else if max_th / self.line_height >= *self.contents then
         need_vsb := 1
      else
         need_vsb := 2

      if min_tw >= self.max_width then
         need_hsb := 0
      else if max_tw >= self.max_width then
         need_hsb := 1
      else
         need_hsb := 2

      #
      # Case analysis on flags to set up correct scroll bars, text width
      # and height fields.
      #
      if (need_vsb < 2) & (need_hsb < 2) then {
         #
         # No scroll bars.
         #
         self.th := max_th
         self.tw := max_tw
         (\self.vsb)$finally()
         (\self.hsb)$finally()
         self.vsb := self.hsb := &null
      } else if (need_hsb + need_vsb > 2) then {
         #
         # Two scroll bars.
         #
         if /self.vsb := ScrollBar() then
            new_vsb := 1
         if /self.hsb := ScrollBar() then {
            self.hsb$set_is_horizontal()
            new_hsb := 1
         }

         self.th := min_th
         self.tw := min_tw

         self.vsb$set_pos(self.w - SB_SIZE - BORDER_WIDTH, BORDER_WIDTH)
         self.vsb$set_size(SB_SIZE, self.h - SB_SIZE - BORDER_WIDTH * 2)

         self.hsb$set_pos(BORDER_WIDTH, self.h - SB_SIZE - BORDER_WIDTH)
         self.hsb$set_size(self.w - SB_SIZE - BORDER_WIDTH * 2, SB_SIZE)
      } else if (need_hsb = 0) & (need_vsb = 2) then {
         #
         # One vertical scroll bar.
         #
         if /self.vsb := ScrollBar() then
            new_vsb := 1
         (\self.hsb)$finally()
         self.hsb := &null

         self.th := max_th
         self.tw := min_tw

         self.vsb$set_pos(self.w - SB_SIZE - BORDER_WIDTH, BORDER_WIDTH)
         self.vsb$set_size(SB_SIZE, self.h  - BORDER_WIDTH * 2)
      } else if (need_hsb = 2) & (need_vsb = 0) then {
         #
         # One horizontal scroll bar.
         #
         if /self.hsb := ScrollBar() then {
            self.hsb$set_is_horizontal()
            new_hsb := 1
         }
         (\self.vsb)$finally()
         self.vsb := &null

         self.th := min_th
         self.tw := max_tw

         self.hsb$set_pos(BORDER_WIDTH, self.h - SB_SIZE - BORDER_WIDTH)
         self.hsb$set_size(self.w  - BORDER_WIDTH * 2, SB_SIZE)
      }

      #
      # Initialize scroll bars.
      #
      if \self.vsb then {
         self.vsb$set_page_size(self.th / self.line_height)
         self.vsb$set_total_size(*self.contents)
         if \new_vsb then {
            self.vsb$set_increment_size(1)
            self.vsb$set_value(0)
            self.vsb$final_setup(self$get_parent_Dialog(), self)
            self.vsb$resize()
            self.vsb$firstly()
         } else
            self.vsb$resize()
      }

      if \self.hsb then {
         self.hsb$set_page_size(self.tw)
         self.hsb$set_total_size(self.max_width)
         if \new_hsb then {
            self.hsb$set_increment_size(TextWidth(self.cwin, "m"))
            self.hsb$set_value(0)
            self.hsb$final_setup(self$get_parent_Dialog(), self)
            self.hsb$resize()
            self.hsb$firstly()
         } else
            self.hsb$resize()
      }
   end

   #
   # Re-draw the text area.  Use double-buffering to avoid flicker.
   #
   method refresh(redraw)
      line := self$get_line()
      left_pos := self$get_left_pos()

      #
      # Do nothing unless have to
      #
      if /redraw & (\self.last_refresh_x = line) & (\self.last_refresh_y = left_pos) then
         return

      #
      # Save present co-ordinates
      #
      self.last_refresh_x := line
      self.last_refresh_y := left_pos

      self$text_area_to_buffer()
      self$do_shading(self.cbwin)

      #
      # Copy buffer to window
      #
      CopyArea(self.cbwin, self.cwin, self.tx, self.ty, self.tw, self.th, self.tx, self.ty)
   end

   method display(buffer_flag)
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)
      self$text_area_to_buffer()

      (\self.vsb)$display(1)
      (\self.hsb)$display(1)

      self$do_shading(self.cbwin)
      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   ##
   #  This method is overridden by the subclass to draw the given
   #  line at the given position
   #  @param N  The object to be drawn
   #  @param left_pos  The left position it should be drawn at
   #  @param yp   The y position it should be drawn at
   #  @param i   The index into the data corresponding to N
   #
   method draw(N, left_pos, yp, i)
      error("draw() must be overridden in subclass")
   end

   method text_area_to_buffer()
      line := self$get_line()
      left_pos := self$get_left_pos()

      EraseRectangle(self.cbwin, self.tx, self.ty, self.tw, self.th)

      #
      # Number of lines to draw
      #
      nlines := (\self.vsb)$get_page_size() | *self.contents

      Clip(self.cbwin, self.tx, self.ty, self.tw, self.th)
      rev := Clone(self.cbwin, "drawop=reverse")

      yp := self.ty + self.line_height / 2

      #
      # Write the lines
      #
      every l := self.contents[i := line to line + nlines - 1] do {
         draw(l, left_pos, yp, i)
         yp +:= self.line_height
      }

      Uncouple(rev)
      rev := &null
      Clip(self.cbwin)
      return
   end

#
#  return the line after the "\t" are replaced with the correct
#  amount of spaces
#
   method actual_line(tab_line)  #swj
   posx := 0
   sblnks := 0

   tab_line2 := repl(" ",*tab_line)
   tab_line2 := tab_line

   tab_line ? {
        while x12 := move(1)  do {
          if x12 == "\t" then {
             posx := posx + 1
             tab_line2 :=  handle_tab_texts(posx,tab_line2)
             sblnks := sblnks + (8 -  (posx-1)%8)
             posx := posx + (8 -  (posx-1)%8) - 1
          }
          else
             posx := posx + 1
        }
   }

   return tab_line2

   end

##
#  helper method for actual_line
###
   method handle_tab_texts(posx,tab_line2)  #swj
   tablen := " "
   seg1 := ""
   seg2 := ""


   tablen := repl(" ",8 -  (posx-1)%8)
   seg1 := tab_line2[1:posx]
   seg2 := tab_line2[posx+1:0]
   tab_line2 := seg1 || tablen || seg2

   return tab_line2
   end

   initially
      self$Component.initially()
      self$set_accepts_tab_focus()
      self.checked := []
end

##
#  This class represents a node in a {Tree} object.
#
class Node(
   label,
   bmps,
   always_expandable,
   depth,
   is_open,
   subnodes,
   draw_line
   )

   ##
   #  Generate all the {Nodes} in this subtree, including this {Node},
   #  in preorder ordering.
   #
   method generate_all_preorder()
      suspend self | (!subnodes)$generate_all_preorder()
   end

   ##
   #  Generate all the {Nodes} in this subtree, including this {Node},
   #  in postorder ordering.
   #
   method generate_all_postorder()
      suspend (!subnodes)$generate_all_postorder() | self
   end

   ##
   #  Generate all the open {Nodes} in this subtree, including this {Node},
   #  in preorder ordering.
   #
   method generate_open_preorder()
      suspend self
      if \self.is_open then
         suspend (!subnodes)$generate_open_preorder()
   end

   ##
   #  Generate all open {Nodes} in this subtree, including this {Node},
   #  in postorder ordering.
   #
   method generate_open_postorder()
      if \self.is_open then
         suspend (!subnodes)$generate_open_postorder()
      suspend self
   end

   ##
   #  Expand all the {Nodes} below this node.
   #
   method expand()
      every n := generate_all_postorder() do
         if *n.subnodes > 0 then
            n.is_open := 1
   end

   ##
   #  Set the label for this node.
   #
   method set_label(x)
      return self.label := x
   end

   ##
   #  Set the bitmaps for this node.  The parameter should provide a list of 3
   #  bitmaps.  The first is displayed if the {Node} is open and has subnodes, the
   #  second is displayed if the {Node} is closed and has subnodes, and the third is
   #  displayed if the node has no subnodes.
   #  @param x  A list of 3 bitmaps.
   #
   method set_bmps(x)
      return self.bmps := x
   end

   ##
   #  Add the given {Node} to this {Node}'s list of subnodes.
   #  @param  The {Node} to add.
   #
   method add(n)
      return put(subnodes, n)
   end

   ##
   #  This configures the {Node} so that it is always treated as though it has subnodes
   #  for display purposes, event though it may in fact have no subnodes.
   #
   method set_always_expandable()
      return always_expandable := 1
   end

   ##
   #  Toggle the opened status of the {Node}.
   #
   method toggle_opened()
      return is_open := if /is_open then 1 else &null
   end

   ##
   #  Delete the given {Node} from the subnodes.
   #
   method node_delete(n)
      return node_delete2(self, n)
   end

   method node_delete2(x, n)
      every i := 1 to *x.subnodes do {
         if n === x.subnodes[i] then {
            x.subnodes := x.subnodes[1 : i] ||| x.subnodes[i + 1 : 0]
            return
         } else {
            if node_delete2(x.subnodes[i], n) then
               return
         }
      }
   end

   initially
      subnodes := []
end

##
#  This class represents a tree object.  An {Event} of code 0 is generated when a click down
#  occurs on a {Node};  of code 1 when the a click up occurs and of code 2 when a node is
#  expanded/contracted by a click on the small +/- icons.
#
class Tree : ScrollArea(
   root_node,
   default_bmps,
   col_w,
   bmp_w,
   bmp_h,
   plus,
   minus,
   little_h,
   little_w
   )

   method get_line_height()
      res:= WAttrib(self.cwin, "fheight")
      #
      # Ensure the line height is slightly greater than the
      # bitmap height
      #
      res <:= \bmp_h + 4
      return res
   end

   method get_max_width()
      mw := 0
      every s := !self.contents do
         mw <:= col_w * s.depth + col_w + TextWidth(self.cwin, s.label)
      return mw
   end

   ##
   #  Expand all the nodes in the {Tree}.
   #
   method expand()
      if \root_node then {
         sels := object_get_selections()
         set_no_updates()
         root_node$expand()
         set_contents(flatten())
         object_set_selections(sels)
         clear_no_updates()
      }
   end

   ##
   #  Set the default bitmaps for each {Node} in the {Tree}.  The parameter should be
   #  a list of three bitmaps;  see {Node} above for an explanation.
   #  @param l  The list of bitmaps.
   #
   method set_default_bmps(l)
      return default_bmps := l
   end

   ##
   #  Set the root node of the {Tree}.
   #
   method set_root_node(r)
      root_node := r
      if /r then
         set_contents([])
      else {
         root_node.is_open := 1
         compute_bmp_wh()
         sels := object_get_selections()
         set_no_updates()
         set_contents(flatten())
         object_set_selections(sels)
         clear_no_updates()
      }
      return root_node
   end

   method compute_bmp_wh()
      bmp_w := bmp_h := 0

      every n := root_node$generate_all_preorder() do {
         bmps := \n.bmps | default_bmps
         bmp_w <:= img_width(bmps[1])
         bmp_w <:= img_width(bmps[2])
         bmp_w <:= img_width(bmps[3])
         bmp_h <:= img_height(bmps[1])
         bmp_h <:= img_height(bmps[2])
         bmp_h <:= img_height(bmps[3])
      }

      #
      # The column width is slightly wider than the bitmap width
      #
      col_w := bmp_w + 4
   end

   ##
   #  This method returns a flat list of all the {Nodes} in the tree that are
   #  currently displayed.
   #  @return  A list of nodes.
   #
   method flatten()
      l := []
      flatten2(l, root_node, "")
      return l
   end

   method flatten2(l, n, dl)
      n.draw_line := dl
      n.depth := *dl
      put(l, n)
      if \n.is_open then {
         every sub := n.subnodes[1 to *n.subnodes - 1] do
            flatten2(l, sub, dl || "y")
         flatten2(l, n.subnodes[-1], dl || "n")
      }
   end

   method handle_press(e)
      if \ (self.select_one | self.select_many) & (self.tx <= &x < self.tx + self.tw) & (self.ty  <= &y < self.ty + self.th) then {
         #
         # Compute line clicked
         #
         lno := (&y - self.ty) / self.line_height
         l := lno + self$get_line()

         if self.which_down := (self$get_last_line() >= l) then {
            if \self.select_many & (&shift | &control) then {
               #
               # Click with shift/ctrl - the state will end here.
               #
               if &control then
                  self.checked[self.which_down] := if /self.checked[self.which_down] then 1 else &null
               else {
                  #
                  # &shift
                  #
                  if \self.prev_down then {
                     if self.prev_down > self.which_down then
                        every self.checked[self.which_down to self.prev_down] := 1
                     else
                        every self.checked[self.prev_down to self.which_down] := 1
                  } else
                     self.checked[self.which_down] := 1
               }
               self.prev_down := self.which_down
               self.which_down := &null
               self$refresh(1)
               return _Event(e, self, 1)
            } else {
               self.checked := list(*self.contents)
               N := self.contents[which_down]
               if (*N.subnodes > 0) | \N.always_expandable then {
                  #
                  # Check for click on little +/- icon.
                  #
                  yp := self.ty + self.line_height / 2 + self.line_height * lno - little_h / 2
                  xp := self$get_left_pos() + (N.depth - 1) * col_w + little_w / 2
                  if (xp <= &x < xp + little_w) & (yp <= &y < yp + little_h) then {
                     #
                     # Clicking on the little icon ends the sequence, and sets the selection
                     # to the given node.
                     #
                     N.is_open := if /N.is_open then 1 else &null
                     set_no_updates()
                     set_contents(flatten())
                     checked[which_down] := 1
                     clear_no_updates()
                     is_held := &null
                     self.prev_down := self.which_down
                     self.which_down := &null
                     return _Event(e, self, 2)
                  }
               }
               #
               # Normal click down
               #
               self.is_held := 1
               self.checked := list(*self.contents)
               self$refresh(1)
               return _Event(e, self, 0)
            }
         }
      }
   end

   method draw(N, left_pos, yp, i)
      dashed := Clone(self.cbwin, "pattern=gray", "fillstyle=textured")
      lp := left_pos
      every j := 1 to N.depth - 1 do {
         if N.draw_line[j] == "y" then
            DrawLine(dashed, lp + col_w / 2, yp - line_height / 2, lp + col_w / 2, yp + line_height / 2)
         lp +:= col_w
      }
      if N.depth > 0 then {
         if N.draw_line[N.depth] == "y" then
            DrawLine(dashed, lp + col_w / 2, yp - line_height / 2, lp + col_w / 2, yp + line_height / 2)
         else
            DrawLine(dashed, lp + col_w / 2, yp - line_height / 2, lp + col_w / 2, yp)

         DrawLine(dashed, lp + col_w / 2, yp, lp + col_w + col_w / 2, yp)

         lp +:= col_w
      }

      bmps := \N.bmps | default_bmps
      if (*N.subnodes = 0) & /N.always_expandable then
         img := bmps[3]
      else {
         if \N.is_open then {
            img := bmps[2]
            little := minus
            if *N.subnodes > 0 then
               DrawLine(dashed, lp + col_w / 2, yp, lp + col_w / 2, yp + line_height / 2)
         } else {
            img := bmps[1]
            little := plus
         }
         EraseArea(self.cbwin, lp - col_w / 2 - little_w / 2, yp - little_h / 2, little_w, little_h)
         DrawImage(self.cbwin, lp - col_w / 2 - little_w / 2, yp - little_h / 2, little)
      }
      DrawImage(self.cbwin, lp + col_w / 2 - bmp_w / 2, yp - bmp_h / 2, img)
      left_string(self.cbwin, lp + col_w, yp, N.label)

      if \self.checked[i] | i = \self.which_down then
         FillRectangle(rev, lp + col_w,
                       yp - self.line_height / 2, TextWidth(self.cbwin, N.label), self.line_height)

      Uncouple(dashed)
   end

   initially
      self$ScrollArea.initially()
      plus := img_style("plus")
      minus := img_style("minus")
      little_w := img_width(plus)
      little_h := img_height(plus)
      default_bmps := [img_style("closed_folder"), img_style("open_folder"), img_style("file")]
end

##
#  This class displays a list of strings.
#
#  mode, then optionally the user can be
#  allowed to select either one line only, or several lines.
#
class TextList : ScrollArea()
   #
   # Used by List to determine an appropriate size for the
   # drop-down list.
   #
   method set_ideal_size(min_w, max_w, min_h, max_h)
      fh := WAttrib(self.cwin, "fheight")

      #
      # Compute longest line
      #
      mw := 0
      every s := !self.contents do
         mw <:= TextWidth(self.cwin, s)

      #
      # Set the width needed, ensuring within min/max dimensions requested
      #
      self.w_spec := mw + 2 * TX_PADDING
      self.w_spec <:= min_w
      self.w_spec >:= max_w

      #
      # Set the height needed, checking for presence of HSB
      #
      if self.w_spec - 2 * TX_PADDING >= mw then
         self.h_spec := *self.contents * fh + 2 * TY_PADDING
      else
         self.h_spec := *self.contents * fh + 2 * TY_PADDING + SB_SIZE

      self.h_spec <:= min_h
      self.h_spec >:= max_h
   end

   method draw(s, left_pos, yp, i)
      s :=  actual_line(s)

      left_string(self.cbwin, left_pos, yp, s)

      if \self.checked[i] | i = \self.which_down then
         FillRectangle(rev, self.tx, yp - self.line_height / 2, self.tw, self.line_height)
   end
end

##
#  A scrollable editable text area.  An {Event} is generated whenever the
#  contents are changed by the user.
#
class EditableTextList : ScrollArea(
   printable,               # The printable characters
   cursor_x,
   cursor_y,
   changed,
   long_line,
   moved,
   startdragx,
   enddragx,
   startdragy,
   enddragy,
   donedrag
   )

   method set_contents(x)
      self.contents := x
      if *self.contents = 0 then
         #
         # Must have somewhere for the cursor to go.
         #
         self.contents := [""]

      if \ (\self.parent_Dialog).is_open then {
         long_line := &null
         self.cursor_x := self.cursor_y := 1
         compute_and_redisplay()
      }
      return x
   end

 
   #
   # Move cursor y to line n, and constrain x within range of that line.
   #
   method set_cursor_y(n)
      self.cursor_y := n
      #
      # Constrain x within new line
      #
#      self.cursor_x >:= *self.contents[self.cursor_y] + 1
      self.cursor_x >:= *(actual_line(self.contents[self.cursor_y])) + 1
      return n
   end

   #
   # Move cursor so that it is in the text area, if possible.  May not
   # be possible if cursor at end of line to the left of the text area.
   #
   method constrain_cursor()
      if self.cursor_y < self$get_line() then
         self$set_cursor_y(self$get_line())
      else if self.cursor_y >= self$get_line() + (\self.vsb)$get_page_size() then
         self$set_cursor_y(self$get_line() + (\self.vsb)$get_page_size() - 1)

      # use the actual line with the tab offsets to test position
      s := self.contents[self.cursor_y] || " "
      s :=  actual_line(s)

      i := TextWidth(self.cwin, s[1:self.cursor_x])
      j := i + TextWidth(self.cwin, s[self.cursor_x])

      l := self$get_left_pos()
      if self.tx - l > i then {
         while (self.cursor_x < *s) & (TextWidth(self.cwin, s[1:self.cursor_x]) < self.tx - l) do
            self.cursor_x +:= 1
      } else if self.tx - l + self.tw < j then {
         while (self.cursor_x > 1) & TextWidth(self.cwin, s[1:self.cursor_x + 1]) > self.tx - l + self.tw do
            self.cursor_x -:= 1
      }
   end

   #
   # Move the text area displayed so that the cursor is on the screen.
   #
   method constrain_line()

      

      if self.cursor_y < self$get_line() then
         self.vsb$set_value(self.cursor_y - 1)
      else if self.cursor_y >= self$get_line() + (\self.vsb)$get_page_size() then
         self.vsb$set_value(self.cursor_y - self.vsb$get_page_size())
   
      s := self.contents[self.cursor_y]
      
#     use the actual line with the tab offsets to test position swj
      s :=  actual_line(s) || " "

      i := TextWidth(self.cwin, s[1:self.cursor_x])
      j := i + TextWidth(self.cwin, s[self.cursor_x])

      l := self$get_left_pos()
      if self.tx - l > i then
         self.hsb$set_value(i)
      else if self.tx - l + self.tw < j then
         self.hsb$set_value(j - self.tw)
   end

   method handle_notify(e)
      if e$get_component() === (\self.vsb | \self.hsb) then {
         self$constrain_cursor()
         self$refresh()
      }
   end

   method handle_event(e)
      if E := (\self.vsb)$handle_event(e) then {
         #
         # Handled by VSB; amend line number and refresh contents
         #
         self$constrain_cursor()
         self$refresh()
      } else if E := (\self.hsb)$handle_event(e) then {
         #
         # Handled by HSB; amend left offset and refresh
         #
         self$constrain_cursor()
         self$refresh()
      } else {
       #  write(image(e))
         if e === -11 then fail # window closed, nothing to do?
         old_contents_size := *contents
         old_mw := TextWidth(cwin, contents[long_line])

         changed := moved := &null
         if integer(e) = (&lpress | &rpress | &mpress) then
            handle_press(e)
         else if integer(e) = (&ldrag | &rdrag | &mdrag) then
            handle_drag(e)
         else if integer(e) = (&lrelease | &rrelease | &mrelease) then
            handle_release(e)
         else if \self.has_focus then {
            case e of {
               Key_Home : handle_key_home(e)
               Key_End : handle_key_end(e)
               Key_PgUp : handle_key_page_up(e)
               Key_PgDn : handle_key_page_down(e)
               Key_Up : handle_key_up(e)
               Key_Down : handle_key_down(e)
               Key_Left : handle_key_left(e)
               Key_Right : handle_key_right(e)
               "\t" : handle_tab_text(e)
               "\b" : handle_delete_1(e)
               "\r" | "\l": handle_return(e)
               "\^k" : handle_delete_line(e)
               "\^a" : handle_start_of_line(e)
               "\^e" : handle_end_of_line(e)
               "\d" | "\^d" : handle_delete_2(e)
               default : handle_default(e)
            }
         }

         if \moved then {
            #
            # Cursor moved.  Make sure still on screen; update scrollbars,
            # and refresh text.
            #
            self$constrain_line()
            self$refresh(1)
            return _Event(e, self, 0)
         } else if \changed then {
            if (*contents ~= old_contents_size) | /long_line | (old_mw ~= TextWidth(cwin, contents[long_line])) then {
               #
               # Contents changed.  Re-compute all internal fields, ensure on
               # screen and re-display whole object.
               #
               self$set_internal_fields()
               self$constrain_line()
               self$display()
            } else {
               self$constrain_line()
               self$refresh(1)
            }
            return _Event(e, self, 0)
         }
      }
   end

   method handle_press(e)
      if ((self.x <= &x < self.x + self.tw + 2 * TX_PADDING) & (self.y  <= &y < self.y + self.th + 2 * TY_PADDING)) then {

         reset_drag()

         #
         # Button down in region - move to cursor position.
         #
         l := (&y - self.ty) / self.line_height
         nlines := self$get_page_size()
         l <:= 0
         l >:= nlines - 1

         self.cursor_y := l + self$get_line()

         #
         # Set cursor_x.
         # Use the actual line with the tab offsets to test position
         #
         s := self.contents[self.cursor_y] || " "
         s :=  actual_line(s)

         # create a mapping for the cursor to skip over the tabs
         sa := map_pos(self.contents[self.cursor_y] || " ")

         put(sa,sa[*sa]+1)

         self.cursor_x := 1
         l := self$get_left_pos()
         while (self.cursor_x < *s) & (TextWidth(self.cwin, s[1:self.cursor_x + 1]) < &x - l) do
              self.cursor_x := sa[self.cursor_x] + 1
         moved := 1
      }
   end

   method handle_start_of_line(e)
      reset_drag()
      cursor_x := 1
      moved := 1
   end

   method handle_end_of_line(e)
      reset_drag()
      s := actual_line(contents[cursor_y])
      cursor_x := *s + 1
      moved := 1
   end

   method handle_key_up(e)
      reset_drag()
      if  self.cursor_y - 1 > 0 then
         self.cursor_y := self.cursor_y - 1
      else
         return
      if  self.cursor_x > *(actual_line(self.contents[self.cursor_y])) + 1 then
         self.cursor_x :=  *(actual_line(self.contents[self.cursor_y])) + 1
      else {
         sa := map_pos2(self.contents[self.cursor_y] || " ")
         put(sa,sa[*sa]+1)
         self.cursor_x := sa[self.cursor_x]
         }
      moved := 1
   end

   method handle_key_home(e)
      reset_drag()
      cursor_y := cursor_x := 1
      moved := 1
   end

   method handle_key_end(e)
      reset_drag()
      cursor_y := *contents
      s := actual_line(contents[cursor_y])
      cursor_x := *s + 1
      moved := 1
   end

   method handle_key_down(e)
      reset_drag()
      if  self.cursor_y + 1 <= *self.contents then
         self.cursor_y := self.cursor_y + 1
      else
         return
      if  self.cursor_x > *self.contents[self.cursor_y] + 1 then
         self.cursor_x := *self.contents[self.cursor_y] + 1
      else {
         sa := map_pos2(self.contents[self.cursor_y] || " ")
         put(sa,sa[*sa]+1)
         self.cursor_x := sa[self.cursor_x]
         }
      moved := 1
   end

   method handle_key_left(e)
      local posn
      reset_drag()
      if self.cursor_x = 1 then {
         if self.cursor_y > 1 then {
            self.cursor_y -:= 1
            s :=  actual_line(self.contents[self.cursor_y])
            self.cursor_x := *s + 1
            }
         }
      else {
        # self.cursor_x > 1
         offset := offset_pos(self.contents[self.cursor_y],self.cursor_x)
         posn := self.cursor_x  - offset - 1
         if self.contents[self.cursor_y][self.cursor_x  - offset - 1] == "\t" then  {
            offset := offset_pos2(self.contents[self.cursor_y],posn)
            self.cursor_x :=  posn + offset
         }
         else {
           self.cursor_x -:= 1
         }
      }
      moved := 1
   end

   method handle_key_right(e)
      reset_drag()
      s := self.contents[self.cursor_y]
      s :=  actual_line(s)

      if self.cursor_x = *s + 1  then {
         if self.cursor_y < *self.contents then {
            self.cursor_x := 1
            self.cursor_y +:= 1
            }
         }
      else {
         sa := map_pos(self.contents[self.cursor_y] || " ")
         put(sa,sa[*sa]+1)
         self.cursor_x := sa[self.cursor_x] + 1
         }
      moved := 1
   end

   method handle_delete_line(e)
      reset_drag()
      if cursor_y < *self.contents then {
         self.contents := self.contents[1:self.cursor_y] ||| self.contents[self.cursor_y + 1 : 0]

         if long_line = self.cursor_y then
            long_line := &null
         else if long_line > self.cursor_y then
            long_line -:= 1
         changed := 1
         cursor_x := 1
      }
   end

   method handle_delete_1(e)
   local posn
      #
      # Delete backspace delete
      #
      reset_drag()
      offset := 0
      posn := 0
      if self.cursor_x = 1 then {
         if self.cursor_y > 1 then {
            self.cursor_x := *(actual_line(self.contents[self.cursor_y - 1])) + 1

            self.contents[self.cursor_y - 1] ||:= self.contents[self.cursor_y]
            self.contents := self.contents[1:self.cursor_y] ||| self.contents[self.cursor_y + 1 : 0]
            self.cursor_y -:= 1
            changed := 1
            long_line := &null
         }
      } else {
         # self.cursor_x > 1
         offset := offset_pos(self.contents[self.cursor_y],self.cursor_x)
         posn := self.cursor_x  - offset - 1
         if self.contents[self.cursor_y][self.cursor_x  - offset - 1] == "\t" then  {
            self.contents[self.cursor_y][self.cursor_x  - offset - 1] := ""
            offset := offset_pos2(self.contents[self.cursor_y],posn)
            self.cursor_x :=  posn + offset
         }
         else {
           self.contents[self.cursor_y][self.cursor_x  - offset - 1] := ""
           self.cursor_x -:= 1
         }
         changed := 1
         if long_line = self.cursor_y then
           long_line := &null
      }
   end

   method handle_delete_2(e)
      #
      # Delete
      #
      reset_drag()
      offset := 0
      offset := offset_pos(self.contents[self.cursor_y],self.cursor_x)
      newcursor_x := self.cursor_x - offset
      if newcursor_x = *contents[cursor_y] + 1 then {
         if self.cursor_y < *contents then {
            self.contents[self.cursor_y] ||:= self.contents[self.cursor_y + 1]
            self.contents := self.contents[1:self.cursor_y + 1] ||| self.contents[self.cursor_y + 2 : 0]
            changed := 1
            long_line := &null
         }
      } else {
         # Cursor not at end of line
         self.contents[self.cursor_y][self.cursor_x  - offset] := ""
         changed := 1
         if long_line = self.cursor_y then
            long_line := &null
      }
   end

   method handle_return(e)
      reset_drag()
      offset := 0
      offset := offset_pos(self.contents[self.cursor_y],self.cursor_x)
      s := self.contents[self.cursor_y]
      newcursor_x := self.cursor_x - offset
      self.contents[self.cursor_y] := s[1:newcursor_x]
      self.contents := self.contents[1:cursor_y + 1] ||| [s[newcursor_x:0]] |||
                         self.contents[cursor_y + 1:0]

      if long_line = self.cursor_y then
         long_line := &null
      else if long_line > self.cursor_y then
         long_line +:= 1

      self.cursor_y +:= 1
      self.cursor_x := 1
      changed := 1
   end

   method handle_tab_text(e)
      #
      # Add any printable character at cursor position
      #
      reset_drag()
      offset := 0
      offset := offset_pos(self.contents[self.cursor_y],self.cursor_x)

      if self.cursor_x = 1 then
         self.contents[self.cursor_y] := e || self.contents[self.cursor_y]
      else
         self.contents[self.cursor_y][self.cursor_x - 1 - offset] ||:= e

      self.cursor_x := self.cursor_x + (8 -  (self.cursor_x-1)%8)
      changed := 1

      if TextWidth(cwin, actual_line(self.contents[self.cursor_y])) >
         TextWidth(cwin, self.contents[long_line]) then
            long_line := self.cursor_y
   end

   method handle_default(e)
      #
      # Add any printable character at cursor position
      #
      
      reset_drag()
      offset := 0
      offset := offset_pos(self.contents[self.cursor_y],self.cursor_x)

      if type(e) == "string" & not(&control | &meta) & any(printable, e) then {

         #  if (e == "\n" ) then 
         # write("in default2")

         if self.cursor_x = 1 then
            self.contents[self.cursor_y] := e || self.contents[self.cursor_y]
         else
            self.contents[self.cursor_y][self.cursor_x - 1 - offset] ||:= e

         self.cursor_x +:= 1
         changed := 1
         if TextWidth(cwin, self.contents[self.cursor_y]) > TextWidth(cwin, self.contents[long_line]) then
            long_line := self.cursor_y
      }
   end

   method handle_key_page_up(e)
      reset_drag()
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i - self.vsb.page_size)
         self$constrain_cursor()
         self$refresh()
         }
   end

   method handle_key_page_down(e)
      reset_drag()
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i + self.vsb.page_size)
         self$constrain_cursor()
         self$refresh()
         }
   end

   method resize()
      self$ScrollArea.resize()
      self$constrain_line()
   end

   method handle_release(e)
      if ((self.x <= &x < self.x + self.tw + 2 * TX_PADDING) &
            (self.y  <= &y < self.y + self.th + 2 * TY_PADDING)) then {
         donedrag := 0
         moved := 1
         }
   end

   method reset_drag()
      enddragx := startdragx
      enddragy := startdragy
   end

   method handle_drag(e)

      if ((self.x <= &x < self.x + self.tw + 2 * TX_PADDING) &
            (self.y  <= &y < self.y + self.th + 2 * TY_PADDING)) then {

         #
         # Button down in region - move to cursor position.
         #
         l := (&y - self.ty) / self.line_height
         nlines := self$get_page_size()

     #    l <:= 0
     #    l >:= nlines - 1

         if l < 0 then
            l := 0

         if l > nlines - 1 then
            l := nlines - 1

         self.cursor_y := l + self$get_line()

         if (self.cursor_y > 1) & (self.cursor_y = self$get_line()) then {
            self.vsb$set_value(self.cursor_y - 2)
            }

         if self.cursor_y + 1  >= self$get_line() + (\self.vsb)$get_page_size()
           then {
            self.vsb$set_value((self.cursor_y + 1) - self.vsb$get_page_size())
            }

        #
        # Set cursor_x
        #
#     use the actual line with the tab offsets to test position swj

        s := self.contents[self.cursor_y] || " "
        s :=  actual_line(s)

#     create a mapping for the cursor to skip over the tabs
        sa := map_pos(self.contents[self.cursor_y] || " ")
        put(sa,sa[*sa]+1)

        self.cursor_x := 1
        l := self$get_left_pos()
        while (self.cursor_x < *s) & (TextWidth(self.cwin, s[1:self.cursor_x + 1]) < &x - l)
        do {
           self.cursor_x := sa[self.cursor_x] + 1
           if self.cursor_x = *s + 1  then {
              if self.cursor_y < *self.contents then {
                 self.cursor_y +:= 1
                 s1 := actual_line(self.contents[self.cursor_y]) || " "
                 self.cursor_x := *s1
                 }
              }
          }  # while

 #    self.hsb$set_value(self.cursor_x)

      if donedrag = 0 then {
         startdragx := self.cursor_x
         startdragy := self.cursor_y
         donedrag := 1
         }

       enddragx := self.cursor_x
       enddragy := self.cursor_y
       moved := 1
       } # if in region
   end
#
########################################
method set_selection(s)
  self.has_focus := 1

  every j := 1 to *s do {
    if j < *s then
      stng := s[j] || "\n"
    else
      stng := s[j]

  every i := 1 to *stng do
     handle_event(stng[i])
  }

  self.has_focus := &null


end
####################
  method get_selection()
  local st, lst, l
  st := ""
  lst := []
  l := ""


   if (enddragx = startdragx ) & (enddragy = startdragy) then {
      l := self.contents[enddragy]
      st := l[startdragx:startdragx + 1]
      put(lst,st)
      return(lst) 
   }

  
  line := 1
  nlines :=  *self.contents
     
  every l := self.contents[i := line to line + nlines - 1] do {
     st := get_region(l, i)
     if *st > 0 then 
       put(lst,st)
  } 

  return(lst) 

  end

method get_region(s, i)
  s2 := ""
   
  s :=  actual_line(s)


#  if no vertical drag just current line
  if ( i = startdragy) & (startdragy = enddragy)  then {
      if startdragx < enddragx then {   # forward drag
         s2 := s[startdragx:enddragx]
      }

      if startdragx > enddragx then {    # backward drag
         s2 := s[enddragx+1:startdragx + 1]
      }
      return s2
  }
# if drag on current line and a vertical drag
# for forward drag need to get whole line for backward
# need to get line up to start of drag


  if ( i = startdragy  )  then {
    if i <  enddragy then {  # for forward drag get the whole line
       s2 :=  s[startdragx:0]
       return s2
       
    }
    if  i >  enddragy  then { # reverse drag get the 1st part to start x
        if startdragx + 1 > *s then
            s2 := s[1:startdragx]
         else
            s2 := s[1:startdragx+1]
         return s2
    }

  }

# for the last endragy line  on vertical drag


  if (i = enddragy)  then {
     if (i >  startdragy )  then { # for forward drag
        if enddragx > *s then
           s2 := s[1:*s+1]
        else
            s2 := s[1:enddragx+1]
     }
     if ( i <  startdragy )  then { # for reverse drag
        if enddragx <= *s then {
           s2 := s[enddragx+1:0]
        }
     }
     return s2
  }

# fill in all the lines in between

  # for forward drag         
  if (i < enddragy & i > startdragy)   then {
      return s
  }
  if (i > enddragy & i < startdragy) then {  # reverse
     return s
  }
  return "" 
end
###############################
method cut_selection()
  local l, lst, ex, ey, sx, sy, i, flag1, starty, endy
  l := ""
  lst := []
  flag1 := []
  put(flag1,"n")

  self.has_focus := 1
  ex := enddragx 
  ey := enddragy
  sx := startdragx
  sy := startdragy

  # No drag just delete character under the cursor
  if (enddragx = startdragx ) & (enddragy = startdragy) then {
      # self.cursor_x := startdragx
      handle_delete_2("\d")
      self.max_width := get_max_width()
      self$set_internal_fields()
      self$display()
      self.has_focus := &null
      return 
  }

  if  (sy = ey)  then { 
        l := self.contents[sy] 
        i := sy
        get_cutregion1(l, i, ex, ey, sx, sy)
        }
  else {
        l := self.contents[sy] 
        get_cutregion(l, sy, ex, ey, sx, sy, flag1)
    
        l := self.contents[ey]  
        get_cutregion(l, ey, ex, ey, sx, sy, flag1)
    
        if ey > sy then  {
          starty := sy
          endy   := ey }
        else {   
          starty := ey
          endy   := sy }

       # go through next loop bottom up because lines are deleted
        i := endy - 1 
        while ( i > starty ) do {
            l := self.contents[i] 
            get_cutregionm(l, i, ex, ey, sx, sy)
            self.max_width := get_max_width()
            i := i - 1
        }

       # delete carriage return on first line if flag set
        if flag1[1] == "y" then {
          l := self.contents[sy] 
          get_cutregioncr(l, sy, ex, ey, sx, sy)
          l := self.contents[ey] 
          get_cutregioncr(l, ey, ex, ey, sx, sy)
         }
     
       }# end else

  self.cursor_y := ey 
  self.cursor_x := ex 
 
  self$set_internal_fields()
  self$display()
   
  self.has_focus := &null

end
method get_cutregionm(s, i, ex, ey, sx, sy)
# fill in all the lines in between
   s :=  actual_line(s)
   self.cursor_y := i
   self.cursor_x := ex 

  # for forward drag         
  if (i < ey & i > sy)   then {
      handle_delete_line("\^k")
      return 
  }
  if (i > ey & i < sy) then {  # reverse
      handle_delete_line("\^k")
      return 
  }
end
#
# cut on just one line no vertical drag
method get_cutregion1(s, i, ex, ey, sx, sy)
  local j
  j := 0

  
  s :=  actual_line(s)
  self.cursor_y := i

#  if no vertical drag just current line
  if ( i = sy) & (sy = ey)  then {
      if sx < ex then {   # forward drag
          every j := sx to ex - 1 do {
             self.cursor_x := sx
             handle_delete_2("\d")
             self.max_width := get_max_width()
          }
            
      }

      if sx > ex then {    # backward drag
          every j := ex  to sx  do {
             self.cursor_x := ex 
             handle_delete_2("\d")
             self.max_width := get_max_width()
          }
      }
      return 
  }

end
method get_cutregion(s,i, ex, ey, sx, sy, flag1)
  local j
  j := 0
    
  s :=  actual_line(s)
  self.cursor_y := i

# if drag on current line and a vertical drag
# for forward drag need to get whole line for backward
# need to get line up to start of drag


  if ( i = sy  )  then {
    if i <  ey then {  # for forward drag get the whole line
       every j :=  sx to *s   do {
          self.cursor_x := sx
          handle_delete_2("\d")
          self.max_width := get_max_width()
       }
       return 
       
    }
    if  i >  ey  then { # reverse drag get the 1st part to start x
          if sx >= *s then  { # last position for cursor
             every j :=  1 to sx + 1   do {
               self.cursor_x := 1
               handle_delete_2("\d")
               self.max_width := get_max_width()
            } 
          }
          else 
          every j :=  1 to sx - 1  do {
              self.cursor_x := 1
              handle_delete_2("\d")
              self.max_width := get_max_width()
            }
       return 
    }

  }

# for the last endragy line  on vertical drag

  if (i = ey)  then {
     if (i >  sy )  then { # for forward drag
         if ex >= *s then  # last character or beyond 
            every j :=  1 to *s + 1 do {
               self.cursor_x := 1
               handle_delete_2("\d")
               self.max_width := get_max_width()
            }
        else {
             flag1[1] := "y"
             every j :=  1 to ex - 1  do {
               self.cursor_x := 1
               handle_delete_2("\d")
               self.max_width := get_max_width()
             }
        }
     }
     if ( i <  sy )  then { # for reverse drag
         flag1[1] := "y"
         every j :=  ex  to *s  do {
            self.cursor_x := ex 
            handle_delete_2("\d")
            self.max_width := get_max_width()
         }
     }
     return 
  }


 
end
method get_cutregioncr(s,i, ex, ey, sx, sy)
  local j
  j := 0
  
  s :=  actual_line(s)
  self.cursor_y := i


# if drag on current line and a vertical drag
# for forward drag need to get whole line for backward
# need to get line up to start of drag


  if ( i = sy  )  then {
    if i <  ey then {  # for forward drag get the whole line
        self.cursor_x := *s + 1
        handle_delete_2("\d")
        self.max_width := get_max_width()
        return 
    }
  }

  if (i = ey)  then {
    if ( i <  sy )  then { # for reverse drag
        self.cursor_x := *s + 1 
        handle_delete_2("\d")
        self.max_width := get_max_width()
     }
     return 
  }


end
###############################
###########################################
#
   method draw(s, left_pos, yp, i)
   newp := 0
   s1 := ""
   s2 := ""
   
   fh := WAttrib(self.cbwin, "fheight")
   asc := WAttrib(self.cbwin, "ascent")
   desc := WAttrib(self.cbwin, "descent")

   s :=  actual_line(s)


#  if no vertical drag just current line
  if ( i = startdragy) & (startdragy = enddragy)  then {
      if startdragx < enddragx then {   # forward drag
          s1 := s[1:startdragx]
          s2 := s[startdragx:enddragx]
          newp := left_pos + TextWidth(self.cbwin, s1)
      }

      if startdragx > enddragx then {    # backward drag
          s1 := s[1:enddragx+1]
          s2 := s[enddragx+1:startdragx]
          newp := left_pos + TextWidth(self.cbwin, s1)
       }

       Fg(self.cbwin, "light gray")
       yp2 :=  yp + ((WAttrib(self.cbwin,"ascent")-
                      WAttrib(self.cbwin,"descent"))/2) - asc
       FillRectangle(self.cbwin,newp, yp2, TextWidth(self.cwin, s2), fh)
  }

# if drag on current line and a vertical drag
# for forward drag need to get whole line for backward
# need to get line up to start of drag


  if ( i = startdragy  )  then {
    if i <  enddragy then {  # for forward drag get the whole line
       s1 := s[1:startdragx]
       s2 :=  s[startdragx:0]
       newp := left_pos + TextWidth(self.cbwin, s1)
    }
    if  i >  enddragy  then { # reverse drag get the 1st part to start x
        if startdragx  >= *s   then
            s2 := s 
        else
            s2 := s[1:startdragx]
        newp := left_pos
    }

    Fg(self.cbwin, "light gray")
    yp2 :=  yp + ((WAttrib(self.cbwin,"ascent")-                                          WAttrib(self.cbwin,"descent"))/2) - asc
    FillRectangle(self.cbwin,newp, yp2, TextWidth(self.cwin, s2), fh)
  }

# for the last endragy line  on vertical drag


  if (i = enddragy)  then {
     if (i >  startdragy )  then { # for forward drag
        if enddragx > *s then
           s2 := s[1:*s+1]
        else
           s2 := s[1:enddragx]
        newp := left_pos
     }
     if ( i <  startdragy )  then { # for reverse drag
        if enddragx <= *s then {
           s1 := s[1:enddragx+1]
           s2 := s[enddragx+1:0]
           newp := left_pos + TextWidth(self.cbwin, s1)
        }
     }
     Fg(self.cbwin, "light gray")
     yp2 :=  yp + ((WAttrib(self.cbwin,"ascent")-
                    WAttrib(self.cbwin,"descent"))/2) - asc
     FillRectangle(self.cbwin,newp, yp2, TextWidth(self.cwin, s2), fh)
  }

# fill in all the lines in between

          # for forward drag         OR       for reverse drag
  if (i < enddragy & i > startdragy) | (i > enddragy & i < startdragy)  then {
     Fg(self.cbwin, "light gray")
     yp2 :=  yp + ((WAttrib(self.cbwin,"ascent")-
                    WAttrib(self.cbwin,"descent"))/2) - asc
     FillRectangle(self.cbwin,left_pos, yp2, TextWidth(self.cwin, s), fh)
  }


  left_stringr(self.cbwin, left_pos, yp, s)

###############################
#  cursor is a BLOCK OR a rectangle
###
      if i = \self.cursor_y then {
        s ||:= " "
        if \self.has_focus then {
          FillRectangle(rev, left_pos + TextWidth(self.cbwin, s[1:self.cursor_x]), 1 + yp - self.line_height / 2, TextWidth(self.cbwin, s[self.cursor_x]), self.line_height)

         }
         else {
            Rectangle(self.cbwin, left_pos + TextWidth(self.cbwin, s[1:self.cursor_x]), 1 + yp - self.line_height / 2, TextWidth(self.cbwin, s[self.cursor_x]), self.line_height)
         }
      }
   end
 

   method get_max_width()
      if /long_line then {
         mw := TextWidth(cwin, actual_line(contents[1]))
         long_line := 1
         every i := 2 to *self.contents do
            if mw <:= TextWidth(cwin, actual_line(contents[i])) then
               long_line := i
      } else
         mw := TextWidth(self.cwin, actual_line(contents[long_line]))

      return mw + TextWidth(self.cwin, " ")
   end

#
#  This method returns the offset( or number of added blanks because
#  of the tabs) up to the end position which is the cursor position
##
    method offset_pos(tab_line,endpos)  #swj
    posx := 0
    sblnks := 0
    linepos := 0
    numtabs := 0

    tab_line ? {
       while x12 := move(1)  do {
          linepos := linepos + 1
          if posx == endpos - 1 then {   # stop at the position in the line with tab offsets
              sblnks := sblnks - numtabs
              return sblnks
          }
          if x12 == "\t" then {
              numtabs := numtabs + 1
              posx := posx + 1
              sblnks := sblnks + (8 -  (posx-1)%8)
              posx := posx + (8 -  (posx-1)%8) - 1
          }
         else
             posx := posx + 1
       }
    }

#  subtract numtabs the positions "\t" since we already counted them

   sblnks := sblnks - numtabs

   return sblnks
   end
####
#
#  This method returns the offset( or number of added blanks because
#  of the tabs) up to the end position which is the position in
#  the line before the blanks were added. (the actual position in
#  self.contents.
##
    method offset_pos2(tab_line,endpos)  #swj
    posx := 0
    sblnks := 0
    linepos := 0
    numtabs := 0

    tab_line ? {
       while x12 := move(1)  do {
          linepos := linepos + 1
          if linepos == endpos  then {   # stop at the tab_line position
              sblnks := sblnks - numtabs
              return sblnks
          }
          if x12 == "\t" then {
              numtabs +:= 1
              posx +:= 1
              sblnks +:= (8 -  (posx-1)%8)
              posx +:= (8 - (posx-1)%8) - 1
          }
         else
             posx +:= 1
       }
    }
   sblnks -:= numtabs
   return sblnks
   end

###
#  Create a list mapping the cursor postion to the correct position
#  This allows the cursor to skip over the tab positions and jump
#  to the next nontab position
####
   method map_pos(pos_line)  #swj
   posx := 0
   sblnks := 0

   pos_line2 := list(*pos_line,1)

   pos_line ? {
       while x12 := move(1)  do {
          if x12 == "\t" then {
              posx := posx + 1
              pos_line2 :=  handle_map_pos(posx,pos_line2)
              posx := posx + (8 -  (posx-1)%8) - 1
          }
          else {
               posx := posx + 1
               pos_line2[posx] := posx
          }
       }
   }

   return pos_line2
  end

###
   method handle_map_pos(posx,pos_line2)  #swj
   tablen := []
   seg1 := []
   seg2 := []

   tabpos := posx + 8 -  (posx-1)%8 - 1
   limit := 8 - (posx-1)%8
   j := 0
   while (j < limit)  do {
         put(tablen,tabpos)
         j := j + 1
    }

    seg1 := pos_line2[1:posx]

   every i := posx + 1 to *pos_line2 do
     put(seg2,pos_line2[i])

   pos_line2 := seg1 ||| tablen ||| seg2
   return pos_line2

   end
###
###
#  Create a list mapping the cursor postion to the correct position
#  This allows the cursor to skip over the tab positions and jump
#  to the next nontab position
####
   method map_pos2(pos_line)  #swj
   posx := 0
   sblnks := 0

   pos_line2 := list(*pos_line,1)

   pos_line ? {
       while x12 := move(1)  do {
          if x12 == "\t" then {
              posx := posx + 1
              pos_line2 :=  handle_map_pos2(posx,pos_line2)
              posx := posx + (8 -  (posx-1)%8) - 1
          }
          else {
               posx := posx + 1
               pos_line2[posx] := posx
          }
       }
   }


   return pos_line2
  end
###
# another method for mapping arrow keys exactly the same as handle_map_pos
# except the tab jump position is one more because it doesn't get
# incremented for arrow keys
###
   method handle_map_pos2(posx,pos_line2)  #swj
   tablen := []
   seg1 := []
   seg2 := []
   tabpos := posx + 8 -  (posx-1)%8
   limit := 8 - (posx-1)%8

   j := 0
   while (j < limit)  do {
         put(tablen,tabpos)
         j := j + 1
    }

    seg1 := pos_line2[1:posx]

   every i := posx + 1 to *pos_line2 do
     put(seg2,pos_line2[i])

   pos_line2 := seg1 ||| tablen ||| seg2
   return pos_line2

   end

   initially
      self$ScrollArea.initially()
      printable := cset(&ascii[33:128])
      self.cursor_x := self.cursor_y := 1
      self.keeps_tabs := 1
      accepts_tab_focus_flag := &null
      startdragx := 0
      enddragx := 0
      startdragy := 0
      enddragy := 0
      donedrag := 0
end

##
#  This class is just a superclass of {List} and {EditList} below.
#
class DropDown(
   selection,
   selection_list,
   tl,
   temp_win
   )

   ##
   #  Set the list selection items to the list x.
   #  @param  The list of items
   #
   method set_selection_list(x)
      return self.selection_list := x
   end

   ##
   #  Return an integer corresponding to the item in the list
   #  presently selected.
   #
   method get_selection()
      return self.selection
   end

   method open_TextList()
      #
      # Initialize and open a list, saving window area below in a temp window.
      #
      self.tl := TextList()
      self.tl$set_contents(self.selection_list)
      self.tl$set_pos(0, self.h)
      self.tl$final_setup(self$get_parent_Dialog(), self)
      self.tl$set_ideal_size(self.w, WAttrib(self$get_parent_win(), "width") - self.x - 10, 0, WAttrib(self$get_parent_win(), "height") - self.y - self.h - 10)
      self.tl$set_select_one()
      self.tl$resize()
      self.tl$firstly()
      self.temp_win := WOpen("canvas=hidden", "size=" || self.tl.w || "," || self.tl.h)
      CopyArea(self$get_parent_win(), self.temp_win, self.tl.x, self.tl.y, self.tl.w, self.tl.h, 0, 0)
      self.tl$got_focus()
   end

   method close_TextList()
      #
      # Close list, restore window
      #
      self.tl$finally()
      EraseRectangle(self$get_parent_win(), self.tl.x, self.tl.y, self.tl.w, self.tl.h)
      CopyArea(self.temp_win, self$get_parent_win(), 0, 0, self.tl.w, self.tl.h, self.tl.x, self.tl.y)
      WClose(self.temp_win)
      self.tl := &null
   end
end

##
#
#  This component is for selecting one string from a list of
#  several.  When a button is pressed a list appears (possibly
#  with a scroll bar) from which one item can be selected.
#
#  An event is generated whenever an item is selected from the
#  list.
#
#  @example
#  @ l := List()
#  @ l$set_selection_list(["Red", "Green", "Yellow", "Blue", "Orange"])
#  @ l$set_size(120)
#  @ l$set_pos(100, 100)
#  @ l$set_selection(2)  # Green will be the first selection
#  @ self$add(l)
#
class List : Component : DropDown(
   b,
   l,
   constant_label
   )

   ##
   #  Set the selected item.
   #  @param x   An index into the list of selectable items.
   #
   method set_selection(x)
     self.selection := x
     self.l$set_label(\self.constant_label | self.selection_list[self.selection])
     self$redisplay()
     return x
   end

   ##
   #  The given string will always appear in the text part of the
   #  component, rather than the currently selected item.
   #
   method set_constant_label(x)
      return self.constant_label := x
   end

   method firstly()
      self$Component.firstly()
      self.b$firstly()
      self.l$firstly()
      self.l$set_label(\self.constant_label | self.selection_list[self.selection])
   end

   method finally()
      #
      # Disposed with text list showing, just get rid of it
      #
      if \self.tl then {
         self$close_TextList()
         self$unique_end()
      }

      self$Component.finally()
      self.b$finally()
      self.l$finally()
   end

   method resize()
      local bw

      if /self.selection_list then
         error("no selection list specified")

      #
      # Re-sized with text list showing, just get rid of it
      #
      if \self.tl then {
         self$close_TextList()
         self$unique_end()
      }

      /self.h_spec := WAttrib(self.cwin, "fheight") + 2 * DEFAULT_TEXT_Y_SURROUND
      self$Component.resize()

      bw := self.h - 2 * BORDER_WIDTH

      #
      # Set button position and size
      #
      b$set_pos(self.w - BORDER_WIDTH - bw, BORDER_WIDTH)
      b$set_size(bw, bw)
      b$resize()

      #
      # Set label position and size
      #
      l$set_pos(BORDER_WIDTH + DEFAULT_TEXT_X_SURROUND, BORDER_WIDTH)
      l$set_size(self.w - bw - 2 * BORDER_WIDTH - 2 * DEFAULT_TEXT_X_SURROUND,  self.h - 2 * BORDER_WIDTH)

      l$resize()

      return
   end

   method display(buffer_flag)
      #
      # Draw text element
      #
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)
      #
      # Draw button and list
      #
      self.b$display(1)
      self.l$display(1)
      self$do_shading(self.cbwin)
      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   method handle_event(e)
      local tmp, E

      if \tl then {
         if E := b$handle_event(e) then {
            if E$get_code() = 0 then {
               #
               # Button pressed whilst list open; just close
               #
               self$close_TextList()
               self$unique_end(1)
            } else
               self.tl.is_held := &null
         } else if E := tl$handle_event(e) then {
            if E$get_code() = 1 then {
               #
               # Selection in list - close textlist, amend label, return event.
               #
               tmp := tl$get_selections()[1]
               self$close_TextList()
               self$unique_end(1)
               if self.selection := \tmp then {
                  if /self.constant_label then
                     self.l$set_label(self.selection_list[self.selection])
                  return _Event(e, self, 0)
               }
            }
         } else if integer(e) = (&lpress | &rpress | &mpress) & not(tl$in_region()) then {
            #
            # Mouse click outside textlist.  Close.
            #
            self$close_TextList()
            self$unique_end()
         }
      } else {
         if b$handle_event(e)$get_code() = 0 then {
            #
            # Button pressed whilst no list; open list
            #
            self$open_TextList()
            self.tl.is_held := 1
            self$unique_start()
         }
      }
   end

   method final_setup(x, y)
      self$Component.final_setup(x, y)
      self.b$final_setup(x, self)
      self.l$final_setup(x, self)
   end

   initially
      self$Component.initially()
      self.l := Label()
      self.l$set_label("")
      self.b := IconButton()
      self.b$toggle_draw_border()
      self.b$set_img(img_style("arrow_down"))
      self.selection := 1
end

##
#  This component functions in the same way as List above, but
#  the item selected may be edited by the user.  An extra
#  method is therefore supplied to get the content, as it may
#  not correspond to an element of the list.
#
#  An event is generated with code 0 if an element of the list
#  is selected, with code 1 if return is pressed, and with
#  code 2 if the user edits the selected item.
#
class EditList : Component : DropDown(
   b,
   tf,
   no_default
   )

   ##
   # Set the text field's filter (see {TextField} for details).
   # @param c  The filter
   #
   method set_filter(c)
      return self.tf$set_filter(c)
   end

   method firstly()
      self$Component.firstly()
      self.b$firstly()
      self.tf$firstly()
      if /self.no_default then {
         #
         # Initialize textfield to default, neither set_contents nor
         # set_selection having been called.
         #
         tf$set_contents(self.selection_list[self.selection])
      }
   end

   method finally()
      #
      # Disposed with text list showing, just get rid of it
      #
      if \self.tl then {
         self$close_TextList()
         self$unique_end()
      }
      self$Component.finally()
      self.b$finally()
      self.tf$finally()
   end

   ##
   #  Return the contents of the selected item (which may have
   #  been edited).
   #
   method get_contents()
      return self.tf$get_contents()
   end

   ##
   #  Set the initial contents of the text to the given string.
   #
   method set_contents(x)
      self.no_default := 1
      return self.tf$set_contents(x)
   end

   ##
   #  Set the selected item.
   #  @param x   An index into the list of selectable items.
   #
   method set_selection(x)
      self.no_default := 1
      self.selection := x
      self.tf$set_contents(self.selection_list[self.selection])
      return x
   end

   method resize()
      local bw

      if /self.selection_list then
         error("no selection list specified")

      #
      # Re-sized with text list showing, just get rid of it
      #
      if \self.tl then {
         self$close_TextList()
         self$unique_end()
      }

      /self.h_spec := WAttrib(self.cwin, "fheight") + 2 * DEFAULT_TEXT_Y_SURROUND
      self$Component.resize()

      bw := self.h - 2 * BORDER_WIDTH

      #
      # Set button position and size
      #
      b$set_pos(self.w - BORDER_WIDTH - bw, BORDER_WIDTH)
      b$set_size(bw, bw)
      b$resize()

      #
      # Set TextField position and size
      #
      tf$set_pos(BORDER_WIDTH, BORDER_WIDTH)
      tf$set_size(self.w - bw - 2 * BORDER_WIDTH,  self.h - 2 * BORDER_WIDTH)
      tf$resize()

      return
   end

   method display(buffer_flag)
      #
      # Draw text element
      #
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)
      #
      # Draw button and list
      #
      self.b$display(1)
      self.tf$display(1)
      self$do_shading(self.cbwin)
      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   method handle_event(e)
      if \tl then {
         if E := b$handle_event(e) then {
            if E$get_code() = 0 then {
               #
               # Button pressed whilst list open; just close
               #
               self$close_TextList()
               self$unique_end(1)
            } else
               self.tl.is_held := &null
         } else if E := tl$handle_event(e) then {
            if E$get_code() = 1 then {
               #
               # Selection in list - close textlist, amend label, return event.
               #
               tmp := tl$get_selections()[1]
               self$close_TextList()
               self$unique_end(1)
               if self.selection := \tmp then {
                  self.tf$set_contents(self.selection_list[self.selection])
                  return _Event(e, self, 0)
               }
            }
         } else if integer(e) = (&lpress | &rpress | &mpress) & not(tl$in_region()) then {
            #
            # Mouse click outside textlist.  Close.
            #
            self$close_TextList()
            self$unique_end()
         }
      } else {
         if b$handle_event(e)$get_code() = 0 then {
            #
            # Button pressed whilst no list; open list
            #
            self$open_TextList()
            self.tl.is_held := 1
            self$unique_start()
         } else if E := tf$handle_event(e) then
            return _Event(e, self, 1 + E$get_code())
      }
   end

   method final_setup(x, y)
      self$Component.final_setup(x, y)
      self.b$final_setup(x, self)
      self.tf$final_setup(x, self)
   end

   method in_region()
      if /self.is_shaded_flag & tf$in_region() then
         return self
   end

   method got_focus()
      self$Component.got_focus()
      self.tf$got_focus()
   end

   method lost_focus()
      self$Component.lost_focus()
      self.tf$lost_focus()
   end

   initially
      self$Component.initially()
      self.accepts_tab_focus_flag := 1
      self.tf := TextField()
      self.tf$toggle_draw_border()
      self.b := IconButton()
      self.b$toggle_draw_border()
      self.b$set_img(img_style("arrow_down"))
      self.selection := 1
end


##
#  This is similar to {MenuBar}, but holds just a single
#  drop-down menu, rather than several.  It may be placed anywhere on
#  the dialog, whereas a {MenuBar} would invariably be placed along the top.
#
class MenuButton : Component(
   menu,
   img,
   is_open
   )

   ##
   #  Set the menu to be displayed when the component is clicked.
   #  @param c   The {Menu}.
   #
   method set_menu(c)
      return self.menu := c
   end

   ##
   #  Set the image to be displayed in the button.
   #  @param x   The Icon to be displayed.
   #
   method set_img(x)
      return self.img := x
   end

   method finally()
      #
      # Disposing with menu open - just close menu
      #
      if \self.is_open then {
         self$set_is_open()
         self$unique_end()
      }
      self$Component.finally()
   end

   method display(buffer_flag)
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawRaisedRectangle(self.cbwin, self.x, self.y, self.w, self.h,2)
      left_string(self.cbwin, self.x + DEFAULT_TEXT_X_SURROUND, self.y + self.h / 2, menu$get_label())
      DrawImage(self.cbwin, self.x + 2 * DEFAULT_TEXT_X_SURROUND + TextWidth(self.cwin, menu$get_label()),  self.y + (self.h - img_height(self.img)) / 2, self.img)
      self$do_shading(self.cbwin)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   #
   # Set the present open menu to x.  If x null, no menu open.
   #
   method set_is_open(x)
      if self.is_open ~=== x then {
         (\self.is_open)$hide()
         self.is_open := x
         (\self.is_open)$display()
         self$display()
      }
      return x
   end

   method handle_event(e)
      if /self.is_open then {
         if integer(e) = (&lpress | &rpress | &mpress) & self$in_region() then {
            self$unique_start()
            self$set_is_open(self.menu)
         }
      } else {
         if self$in_region() then {
            if integer(e) = (&lpress | &rpress | &mpress) then {
               self$set_is_open()
               self$unique_end(1)
               fail
            } else if integer(e) = (&lrelease | &rrelease | &mrelease) then
               fail
         }

         #
         # Not on menu bar, but menu bar open.  Let menu handle event.
         #
         r := self.menu$handle_event(e)
         case r$get_menu_code() of {
            FAIL_1 : {
               #
               # Fail; don't pass event on to other components.
               #
               self$set_is_open()
               self$unique_end(1)
               fail
            }
            FAIL_2 : {
               #
               # Fail and pass event on to other components.
               #
               self$set_is_open()
               self$unique_end()
               fail
            }
            CONTINUE :
               #
               # Fail, but keep unique status.
               #
               fail
            SUCCEED : {
               #
               # Succeed with event.
               #
               self$set_is_open()
               self$unique_end(1)
               return r
            }
            default : stop("internal error")
         }
      }
   end

   method resize()
      #
      # Re-sized with menu open - just close menu
      #
      if \self.is_open then {
         self$set_is_open()
         self$unique_end()
      }

      if /self.menu then
         error("no menu set")

      /self.w_spec := TextWidth(self.cwin, self.menu$get_label()) + 3 * DEFAULT_TEXT_X_SURROUND + img_width(self.img)
      /self.h_spec := WAttrib(self.cwin, "fheight") +  2 * DEFAULT_TEXT_Y_SURROUND
      self$Component.resize()

      self.menu$set_parent_menu_bar(self)
      self.menu$set_abs_coords(self.x, self.y + self.h)
      self.menu$set_label_size()
      self.menu$resize()
   end

   initially
      self$Component.initially()
      self.img := img_style("arrow_down")
end

##
#  This is a popup menu class, namely a menu which pops up under the
#  cursor under the direction of the program (for example when a right
#  click has occurred.
#
class PopupMenu : Component(
   menu,
   is_open
   )

   ##
   #  Set the menu to be displayed when the popup is displayed.
   #  @param c   The {Menu}.
   #
   method set_menu(c)
      return self.menu := c
   end

   method finally()
      #
      # Disposing with menu open - just close menu
      #
      if \self.is_open then {
         self$set_is_open()
         self$unique_end()
      }
      self$Component.finally()
   end

   method display(buffer_flag)
   end

   #
   # Set the present open menu to x.  If x null, no menu open.
   #
   method set_is_open(x)
      if self.is_open ~=== x then {
         (\self.is_open)$hide()
         self.is_open := x
         (\self.is_open)$display()
         self$display()
      }
      return x
   end

   method handle_event(e)
      if \self.is_open then {
         if integer(e) = (&lrelease | &rrelease | &mrelease) & &x = self.x & &y = self.y then
            fail

         r := self.menu$handle_event(e)
         case r$get_menu_code() of {
            FAIL_1 : {
               #
               # Fail; don't pass event on to other components.
               #
               self$set_is_open()
               self$unique_end(1)
               fail
            }
            FAIL_2 : {
               #
               # Fail and pass event on to other components.
               #
               self$set_is_open()
               self$unique_end()
               fail
            }
            CONTINUE : {
               #
               # Fail, but keep unique status.
               #
               fail
            }
            SUCCEED : {
               #
               # Succeed with event.
               #
               self$set_is_open()
               self$unique_end(1)
               return r
            }
            default : stop("internal error")
         }
      }
   end

   method resize()
      #
      # Re-sized with menu open - just close menu
      #
      if \self.is_open then {
         self$set_is_open()
         self$unique_end()
      }

      if /self.menu then
         error("no menu set")

      /self.x_spec := 0
      /self.y_spec := 0
      self.w_spec := self.h_spec := 0
      self$Component.resize()
   end

   ##
   #  Popup the menu at the current cursor position.
   #
   method popup()
      local W
      W := self$get_parent_win()
      self$set_pos(WAttrib(W, "pointerx"), WAttrib(W,"pointery"))
      self$resize()
      self.menu$set_parent_menu_bar(self)
      self.menu$set_abs_coords(self.x, self.y + self.h)
      self.menu$resize()

      if self.menu.y + self.menu.h > WAttrib(W, "height") then
         y1 := 0 <= WAttrib(W, "height") - self.menu.h
      if self.menu.x + self.menu.w > WAttrib(W, "width") then
         x1 := 0 <= WAttrib(W, "pointerx") - self.menu.w

      if \x1 | \y1 then {
         /x1 := self.x
         /y1 := self.y + self.h
         self.menu$set_abs_coords(x1, y1)
         self.menu$resize()

      }
      self$unique_start()
      self$set_is_open(self.menu)
   end
end


##
#  This class is the base from which menu systems are created,
#  other than popup menus.
#
#  Menu items are added to this class; they are not separate
#  components added to the dialog itself.
#
#  The default position is (0, 0); the default size is 100% of
#  the width of the screen and a reasonable height based on the
#  font specified.
#
class MenuBar : Component(
   which_open,
   menus
   )

   ##
   #  Add the {Menu} c to the {MenuBar}.  This will be one drop down
   #  menu.  Items are then added to the {Menu}.
   #  @param c  The {Menu} to add.
   #
   method add(c)
      put(self.menus, c)
   end

   method finally()
      #
      # Disposing with menu open - just close menu
      #
      if \self.which_open then {
         self$set_which_open()
         self$unique_end()
      }
      self$Component.finally()
   end

   method display(buffer_flag)
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawRaisedRectangle(self.cbwin, self.x, self.y, self.w, self.h,1)

      #
      # Draw the menu options with a raised rectangle around the open menu.  m.label_mid_w gives the space for
      # the menu label, which includes DEFAULT_TEXT_X_SURROUND either side of the label itself.  m.label_x is the x position, so
      # m.label_x + DEFAULT_TEXT_X_SURROUND put the string in the centre of its area.
      #
      every m := !menus do {
         if m === \self.which_open then
            DrawRaisedRectangle(self.cbwin, m.label_x, self.y + BORDER_WIDTH, m.label_mid_w, self.h - 2 * BORDER_WIDTH,1)
         left_string(self.cbwin, m.label_x + DEFAULT_TEXT_X_SURROUND, self.y + self.h / 2, m$get_label())
         if \m.is_shaded_flag then
            FilterRectangle(self.cbwin, m.label_x, self.y + BORDER_WIDTH, m.label_mid_w, self.h - 2 * BORDER_WIDTH)
      }
      self$do_shading(self.cbwin)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   #
   # Determine which of the menu labels is selected, if any.  Assumes y pos already tested and in menu bar.
   #
   method which_button()
      every m := !self.menus do {
         if /m.is_shaded_flag & m.label_x <= &x < m.label_x + m.label_mid_w then
            return m
      }
   end

   #
   # Set the present open menu to x.  If x null, no menu open.
   #
   method set_which_open(x)
      #
      # Do nothing if x presently open
      #
      if self.which_open ~=== x then {
         (\self.which_open)$hide()
         self.which_open := x
         (\self.which_open)$display()
         self$display()
      }
      return x
   end

   method handle_event(e)
      if self$in_region() then {
         if integer(e) = (&lpress | &rpress | &mpress) then {
            if t := which_button() then {
               #
               # Pressed on a label - open the menu, starting unique mode if needed.
               #
               if /self.which_open then
                  self$unique_start()
               if t === self.which_open then {
                  #
                  # Clicked on menu already open - close all
                  #
                  self$set_which_open()
                  self$unique_end(1)
               } else
                  self$set_which_open(t)
            } else {
               self$set_which_open()
               self$unique_end(1)
            }
         } else if integer(e) = (&lrelease | &rrelease | &mrelease) & \self.which_open then {
            #
            # Released with menu open.  If not on a label then close menu
            #
            if not(t := which_button()) then {
               self$set_which_open()
               self$unique_end(1)
            }
         } else if integer(e) = (&ldrag | &rdrag | &mdrag) & \self.which_open then {
            #
            # Drag onto a label with menu open
            #
            if t := which_button() then {
               if t === self.which_open then
                  #
                  # Make present menu blank
                  #
                  t$set_which_open()
               else
                  self$set_which_open(t)
            } else
               #
               # Drag with menu open, but not on a label, blank present menu leaving
               # sub menus open
               #
               self.which_open$hide_non_menu()
         }
      } else if \self.which_open then {
         #
         # Not on menu bar, but menu bar open.  Let menu handle event.
         #
         r := self.which_open$handle_event(e)
         case r$get_menu_code() of {
            FAIL_1 : {
               #
               # Fail; don't pass event on to other components.
               #
               self$set_which_open()
               self$unique_end(1)
               fail
            }
            FAIL_2 : {
               #
               # Fail and pass event on to other components.
               #
               self$set_which_open()
               self$unique_end()
               fail
            }
            CONTINUE :
               #
               # Fail, but keep unique status.
               #
               fail
            SUCCEED : {
               #
               # Succeed with event.
               #
               self$set_which_open()
               self$unique_end(1)
               return r
            }
            default : stop("internal error")
         }
      }
   end

   method resize()
      #
      # Re-sized with menu open - just close menu
      #
      if \self.which_open then {
         self$set_which_open()
         self$unique_end()
      }

      /self.x_spec := 0
      /self.y_spec := 0
      /self.w_spec := "100%"
      /self.h_spec := WAttrib(self.cwin, "fheight") +  2 * DEFAULT_TEXT_Y_SURROUND
      self$Component.resize()
      #
      # Compute x, y for each sub-menu
      #
      px := self.x + BORDER_WIDTH
      every m := !self.menus do {
         m$set_parent_menu_bar(self)
         m$set_abs_coords(px, self.y + self.h)
         m$set_label_pos(px, self.y + BORDER_WIDTH)
         m$set_label_size()
         px +:= m.label_mid_w
         m$resize()
      }
   end

   initially
      self$Component.initially()
      self.menus := []
end

##
#  This class is an {_Event} with an extra code.  Its use is internal to
#  the menu system.
#
class MenuEvent : _Event(
   menu_code
   )

   ##
   #  Return the additional code.
   #
   method get_menu_code()
      return self.menu_code
   end
end

##
#  This is the superclass of all the objects that make up the
#  menu system (other than the top level {Components} of course).
#
#  For components that appear in a menu with a label, an
#  optional left/right string/image can be set.
#
class MenuComponent(
   x,
   y,
   w,
   h,
   label,
   label_x,
   label_y,
   label_h,
   label_left_w,
   label_right_w,
   label_mid_w,
   is_sub_menu_flag,
   parent_menu_bar,
   is_shaded_flag,
   label_left,
   img_left,
   img_left_h,
   img_left_w,
   label_right,
   img_right,
   img_right_h,
   img_right_w,
   parent_menu
   )

   method error(s)
      stop("gui.icn : error whilst processing object " || object_class_name(self) || " : " || s)
   end

   method set_parent_menu(x)
      return self.parent_menu := x
   end

   ##
   #  Set the optional left label to the given string.
   #
   method set_label_left(x)
      return self.label_left := x
   end

   ##
   #  Set the optional right label to the given string.
   #
   method set_label_right(x)
      return self.label_right := x
   end

   ##
   #  Set the optional left image to the given Icon image.
   #
   method set_img_left(x)
      self.img_left := x
      self.img_left_w := img_width(self.img_left)
      self.img_left_h := img_height(self.img_left)
      return x
   end

   ##
   #  Set the optional right image to the given Icon image.
   #
   method set_img_right(x)
      self.img_right := x
      self.img_right_w := img_width(self.img_right)
      self.img_right_h := img_height(self.img_right)
      return x
   end

   method set_abs_coords(x, y)
      self.x := x
      self.y := y
      return
   end

   method set_abs_size(w, h)
      self.w := w
      self.h := h
      return
   end

   method is_shaded()
      return \self.is_shaded_flag
   end

   ##
   #  Toggle whether or not the item is shaded.  If it is, it is
   #  displayed in a filtered way and will not accept input.
   #
   method toggle_is_shaded()
      if /self.is_shaded_flag then
         self.is_shaded_flag := 1
      else
         self.is_shaded_flag := &null
      if /self.parent_menu then
         (\self.parent_menu_bar)$redisplay()
   end

   ##
   #  Set the shaded status of the component to shaded.
   #
   method set_is_shaded()
      self.is_shaded_flag := 1
      if /self.parent_menu then
         (\self.parent_menu_bar)$redisplay()
   end

   ##
   #  Set the shaded status of the component to not shaded.
   #
   method clear_is_shaded()
      self.is_shaded_flag := &null
      if /self.parent_menu then
         (\self.parent_menu_bar)$redisplay()
   end

   method set_parent_menu_bar(x)
      return self.parent_menu_bar := x
   end

   method is_sub_menu()
      return \self.is_sub_menu_flag
   end

   method get_label()
      return self.label
   end

   ##
   #  Set the centre label to the given string.
   #
   method set_label(x)
      return self.label := x
   end

   method display_label()
      cw := self.parent_menu_bar.cbwin

      #
      # Draw the left label or image
      #
      if \self.label_left then
         left_string(cw, self.label_x + DEFAULT_TEXT_X_SURROUND, self.label_y + self.label_h / 2, self.label_left)
      else if \self.img_left then
         DrawImage(cw, self.label_x + DEFAULT_TEXT_X_SURROUND, self.label_y + (self.label_h - img_left_h) / 2, img_left)

      #
      # Draw the right label or image
      #
      if \self.label_right then
         left_string(cw, self.label_x + self.parent_menu.max_label_left_w + self.parent_menu.max_label_mid_w, self.label_y + self.label_h / 2, self.label_right)
      else if \self.img_right then
         DrawImage(cw, self.label_x + self.parent_menu.max_label_left_w + self.parent_menu.max_label_mid_w, self.label_y + (self.label_h - img_right_h) / 2, img_right)

      #
      # Draw the centre label
      #
      left_string(cw, self.label_x + self.parent_menu.max_label_left_w + DEFAULT_TEXT_X_SURROUND, self.label_y + self.label_h / 2, self.label)

      #
      # Filter if shaded
      #
      if \self.is_shaded_flag then
         FilterRectangle(cw, self.label_x, self.label_y, self.parent_menu.max_label_mid_w + self.parent_menu.max_label_left_w + self.parent_menu.max_label_right_w, self.label_h)

   end

   method select_event()
      error("select event must be  over-ridden in sub-class")
   end

   method set_label_pos(x, y)
      self.label_x := x
      self.label_y := y
   end

   method set_label_size()
      cw := self.parent_menu_bar.cwin

      if /self.label then
         error("no label specified")

      self.label_h := WAttrib(cw, "fheight") + 2 * DEFAULT_TEXT_Y_SURROUND

      #
      # Set the left hand sizes; the left hand label has DEFAULT_TEXT_X_SURROUND to its left.
      #
      if \self.label_left then
         self.label_left_w := TextWidth(cw, self.label_left) + DEFAULT_TEXT_X_SURROUND
      else if \self.img_left then {
         self.label_left_w :=  self.img_left_w + DEFAULT_TEXT_X_SURROUND
         self.label_h <:=  self.img_left_h + 2 * DEFAULT_TEXT_Y_SURROUND
      } else
         self.label_left_w := 0

      #
      # Set the right hand sizes; this has DEFAULT_TEXT_X_SURROUND to its right.
      #
      if \self.label_right then
         self.label_right_w := TextWidth(cw, self.label_right) + DEFAULT_TEXT_X_SURROUND
      else if \self.img_right then {
         self.label_right_w :=  self.img_right_w + DEFAULT_TEXT_X_SURROUND
         self.label_h <:=  self.img_right_h + 2 * DEFAULT_TEXT_Y_SURROUND
      } else
         self.label_right_w := 0

      #
      # Space for the string and DEFAULT_TEXT_X_SURROUND either side.
      #
      self.label_mid_w := TextWidth(cw, self.label) + 2 * DEFAULT_TEXT_X_SURROUND
   end

   initially

end

##
#  This is the parent class of menu components which popup other menus.
#
class SubMenu : MenuComponent()
   method hide_non_menu()
   end

   method set_which_open(x)
   end

   method resize()
   end

   method display()
      error("display() method must be over-ridden in SubMenu sub-class")
   end

   method handle_event(e)
      error("handle_event() method must be over-ridden in SubMenu sub-class")
   end

   method hide()
      error("hide() method must be over-ridden in SubMenu sub-class")
   end

   initially
      self$MenuComponent.initially()
      self.is_sub_menu_flag := 1
end

##
#  This class encapsulates a drop down menu, or a sub-menu.
#
#  The left, centre and right labels/images of the elements
#  within it are formatted within the menu automatically.
#
class Menu : SubMenu(
   max_label_left_w,
   max_label_mid_w,
   max_label_right_w,
   temp_win,
   which_open,
   menus
   )

   method set_parent_menu_bar(x)
      self$MenuComponent.set_parent_menu_bar(x)
      every (!self.menus)$set_parent_menu_bar(x)
      return
   end

   ##
   #  Add the given component to the Menu.
   #
   method add(c)
      put(self.menus, c)
      c$set_parent_menu(self)
   end

   method get_which_open()
      return self.which_open
   end

   method resize()
      cw := self.parent_menu_bar.cwin

      self.h := self.max_label_left_w := self.max_label_right_w := self.max_label_mid_w := 0

      dy := BORDER_WIDTH

      every m := !self.menus do {
         #
         # Set x, y of label position for sub items.
         #
         m$set_label_pos(self.x + BORDER_WIDTH, self.y + dy)
         #
         # Set their label size.
         #
         m$set_label_size()
         #
         # Increment height; compute maximum label element widths.
         #
         self.h +:= m.label_h
         self.max_label_left_w <:= m.label_left_w
         self.max_label_right_w <:= m.label_right_w
         self.max_label_mid_w <:= m.label_mid_w

         dy +:= m.label_h
      }

      #
      # Height of object is height of total labels within, plus top and bottom border widths.
      #
      self.h +:= 2 * BORDER_WIDTH

      #
      # Width is total of all maximum label elements, plus left and right border widths.
      #
      self.w := self.max_label_left_w + self.max_label_mid_w + self.max_label_right_w + 2 * BORDER_WIDTH

      #
      # Compute x, y positions of sub-menus and descend recursively.
      #
      every m := !self.menus do
         if m$is_sub_menu() then {
            m$set_abs_coords(self.x + self.w, m.label_y - BORDER_WIDTH)
            m$resize()
         }
   end

   #
   # Deduce which label is under pointer, if any
   #
   method which_item()
      every m := !self.menus do {
         if /m.is_shaded_flag & (m.label_y <= &y < m.label_y + m.label_h) then
            return m
      }
   end

   method display()
      if /self.temp_win then {
         #
         # Open a temporary area for the menu and copy.
         #
         self.temp_win := WOpen("canvas=hidden", "size=" || self.w || "," || self.h)
         CopyArea(self.parent_menu_bar$get_parent_win(), self.temp_win, self.x, self.y, self.w, self.h, 0, 0)
      }

      cw := self.parent_menu_bar.cbwin

      #
      # Clear area and draw rectangle around whole
      #
      EraseRectangle(cw, self.x, self.y, self.w, self.h)
      DrawRaisedRectangle(cw, self.x, self.y, self.w, self.h,1)

      #
      # Draw individual items, with rectangle around open sub-item
      #
      every c := !self.menus do {
         c$display_label()
         if c === \self.which_open then
            DrawRaisedRectangle(cw, c.label_x, c.label_y, self.w - 2 * BORDER_WIDTH, c.label_h,1)
      }
      CopyArea(cw, self.parent_menu_bar.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   #
   # If the presently selected item is a sub-menu, don't unselect it;
   # just close any non-sub-menu in it by calling recursively.
   #
   method hide_non_menu()
      if (\self.which_open)$is_sub_menu() then
         return self.which_open$hide_non_menu()
      else
         return self$set_which_open()
   end

   #
   # Set the selected sub item to x, whether or not it's a sub-menu
   #
   method set_which_open(x)
      if self.which_open ~=== x then {
         if (\self.which_open)$is_sub_menu() then
            self.which_open$hide()
         self.which_open := x
         if (\self.which_open)$is_sub_menu() then
            self.which_open$display()
         self$display()
      }
      return x
   end

   #
   # Test whether pointer within label area.  Top and bottom borders are outside this region.
   #
   method in_button_region()
      return (self.x <= &x < self.x + self.w) &  (self.y + BORDER_WIDTH <= &y < self.y + self.h - BORDER_WIDTH)
   end

   method handle_event(e)
      if self$in_button_region() then {
         if integer(e) = (&lpress | &rpress | &mpress) then
            #
            # Mouse press in region.  Open the item where the pointer is
            # or set to null (eg if over a shaded item).
            #
            self$set_which_open(self$which_item() | &null)
         else if integer(e) = (&lrelease | &rrelease | &mrelease) then {
            #
            # Mouse released over region
            #
            if \self.which_open then {
               #
               # If item selected and not a sub-menu, return its selected
               # event.  If sub-menu, this will just stay open.
               #
               if not(self.which_open$is_sub_menu()) then
                  return self.which_open$select_event(e)
            } else
               #
               # Fail completely, don't pass on event.
               #
               return MenuEvent(FAIL_1)
         } else if integer(e) = (&ldrag | &rdrag | &mdrag) then {
            #
            # Drag over region.
            #
            if t := self$which_item() then {
               if t === self.which_open then {
                  #
                  # Drag over label of open sub-item.  If a menu unselect any
                  # items, except sub menus.
                  #
                  if t$is_sub_menu() then
                     t$hide_non_menu()
               } else
                  #
                  # Open the selected item.
                  #
                  self$set_which_open(t)
            } else
               #
               # Not over an item (eg shaded item).  Clear selection.
               #
               self$set_which_open()
         }
      } else {
         #
         # Not in region.
         #
         if integer(e) = (&ldrag | &rdrag | &mdrag) then {
            if (\self.which_open)$is_sub_menu() then
               #
               # Pass event on to open sub menu.
               #
               return self.which_open$handle_event(e)
            else
               #
               # Clear present selection, except sub-menus.
               #
               self$hide_non_menu()
         } else if integer(e) = (&lpress | &rpress | &mpress) then {
            if (\self.which_open)$is_sub_menu() then
               #
               # Try open sub-menu.
               #
               return self.which_open$handle_event(e)
            else
               #
               # Fail completely, pass on event to other objects.
               #
               return MenuEvent(FAIL_2)
         } else if integer(e) = (&lrelease | &rrelease | &mrelease) then {
            if (\self.which_open)$is_sub_menu() then
               #
               # Try open sub-menu.
               #
               return self.which_open$handle_event(e)
            else
               #
               # Fail completely, don't pass on event.
               #
               return MenuEvent(FAIL_1)
         }
      }

      #
      # Every branch that doesn't return falls through to here.  Just
      # wait for next event to come along.
      #
      return MenuEvent(CONTINUE)
   end

   #
   # Close this menu.
   #
   method hide()
      #
      # Recursively close open sub-menu.
      #
      if (\self.which_open)$is_sub_menu() then
         self.which_open$hide()
      self.which_open := &null

      #
      # Restore window area.
      #
      cw := self.parent_menu_bar.cwin
      EraseRectangle(cw, self.x, self.y, self.w, self.h)
      CopyArea(self.temp_win, self.parent_menu_bar$get_parent_win(), 0, 0, self.w, self.h, self.x, self.y)
      WClose(self.temp_win)
      self.temp_win := &null
   end

   initially
      self$SubMenu.initially()
      self.menus := []
      self$set_img_right(img_style("arrow_right"))
end

##
#  This class encapsulates a single text item in a Menu.  It
#  has no additional methods which the user need call other
#  than are contained in its parent class, MenuComponent.
#
class TextMenuItem : MenuComponent()
   #
   # Event to return if item selected.
   #
   method select_event(e)
      return MenuEvent(SUCCEED, e, self, 0)
   end
end

##
#  This class encapsulates a check box in a menu.
#
#  Several {CheckBoxMenuItems} may be added to a {CheckBoxGroup}
#  structure to give "radio buttons" within menus.
#
class CheckBoxMenuItem : Toggle : MenuComponent(
   img_up,
   img_down
   )

   method into_cbg()
      if self.img_up == img_style("box_up") & self.img_down == img_style("box_down") then
         self$set_imgs(img_style("diamond_up"), img_style("diamond_down"))
   end

   ##
   #  Set the up and down images to x and y respectively.  The
   #  default is boxes, unless the component is added to a
   #  {CheckBoxGroup} in which case the default is diamonds.
   #
   method set_imgs(x, y)
      self.img_up := x
      self.img_down := y
      img_width(x) = img_width(y) | error("Image widths differ")
      img_height(x) = img_height(y) | error("Image heights differ")
      self$set_img_left(if /self.is_checked_flag then self.img_up else self.img_down)
      return
   end

   method toggle_is_checked()
      self$Toggle.toggle_is_checked()
      if \self.is_checked_flag then
         self.img_left := self.img_down
      else
         self.img_left := self.img_up
   end

   method set_is_checked()
      self$Toggle.set_is_checked()
      self.img_left := self.img_down
   end

   method clear_is_checked()
      self$Toggle.clear_is_checked()
      self.img_left := self.img_up
   end

   method select_event(e)
      if \self.parent_check_box_group then
         self.parent_check_box_group$set_which_one(self)
      else
         self$toggle_is_checked()
      return MenuEvent(SUCCEED, e, self, 0)
   end

   initially
      self$MenuComponent.initially()
      self$set_imgs(img_style("box_up"), img_style("box_down"))
end

$define SEPARATOR_HEIGHT 4

##
#  This is simply a horizontal bar in a {Menu}, for decorative purposes.
#  It has no methods which the user need invoke.
#
class MenuSeparator : MenuComponent()
   method set_label_size()
      cw := self.parent_menu_bar.cwin
      self.label_h := SEPARATOR_HEIGHT + 2 * DEFAULT_TEXT_Y_SURROUND
      self.label_right_w := 0
      self.label_left_w := 0
      self.label_mid_w := 0
   end

   method select_event(e)
      return MenuEvent(SUCCEED, e, self, 0)
   end

   method display_label()
      cw := self.parent_menu_bar.cbwin
      DrawRaisedRectangle(cw, self.label_x, self.label_y + (self.label_h - SEPARATOR_HEIGHT) / 2, self.parent_menu.max_label_mid_w + self.parent_menu.max_label_left_w + self.parent_menu.max_label_right_w, SEPARATOR_HEIGHT,1)
   end

   initially
      self$MenuComponent.initially()
      self.is_shaded_flag := 1
end

$define CHANGE_SIZE_BORDER 6
$define MIN_BUTTON_WIDTH 20

##
#  This class provides one column within a {Table}, which
#  displays a table of data.  A column has a label with a
#  button which produces an event when clicked.  The column may
#  be expanded or contracted by dragging the right edge of the
#  button.
#
#  The label is set by calling the {set_label(x)} method of the
#  parent class, {TextButton}.
#
class TableColumn : TextButton(
   parent_table,
   column_width,
   change_size_mode,
   temp_pointer
   )

   method handle_event(e)
      if (integer(e) = (&lpress | &rpress | &mpress)) & self$in_region() & (self.x + self.w - CHANGE_SIZE_BORDER <= &x < self.x + self.w) then {
         self.change_size_mode := 1
         temp_pointer := WAttrib(get_parent_win(), "pointer")
         WAttrib(get_parent_win(), "pointer=sb h double arrow")
      } else if \self.change_size_mode & (integer(e) = (&lrelease | &rrelease | &mrelease)) then {
         WAttrib(get_parent_win(), "pointer=" || temp_pointer)
         self.column_width := &x - self.x
         self.column_width <:= MIN_BUTTON_WIDTH
         self.change_size_mode := &null
         self.parent_table$set_internal_fields()
         self.parent_table$display()
      } else
         return self$TextButton.handle_event(e)
   end

   method in_region()
      return (self.parent_table.tx <= &x < self.parent_table.tx + self.parent_table.tw) & self$TextButton.in_region()
   end

   ##
   #  Set the initial width of the column, in pixels; this must be
   #  specified.
   #  @param x  The width
   #
   method set_column_width(x)
      return self.column_width := x
   end

   method set_parent_table(x)
      return self.parent_table := x
   end

   method check_width()
      if /self.column_width then
         error("no column width specified")
   end

   method resize()
      self$set_size(self.column_width, self.parent_table.head_h)
      self$TextButton.resize()
      return
   end

   method display(buffer_flag)
      W := if /buffer_flag then self.cwin else self.cbwin
      Clip(W, self.parent_table.tx, self.parent_table.head_y, self.parent_table.tw, self.parent_table.head_h)
      self$TextButton.display(buffer_flag)
      cw := Clone(W, "fillstyle=textured", "pattern=lightgray")
      FillRectangle(cw, self.x + self.w - CHANGE_SIZE_BORDER, self.y + BORDER_WIDTH, CHANGE_SIZE_BORDER - BORDER_WIDTH, self.h - 2 * BORDER_WIDTH)
      Uncouple(cw)
      Clip(W)
   end

   initially
      self$TextButton.initially()
      self.internal_alignment := "l"
end

##
#  This class displays a table, the columns of which are set up
#  using TableColumns.
#
class Table : Component(
   contents,
   max_width,
   head_x,
   head_y,
   head_h,
   columns,
   tx,
   ty,
   tw,
   th,
   hsb,
   vsb,
   last_refresh_x,
   last_refresh_y,
   line_height,
   checked,
   select_one,
   select_many,
   prev_down,
   which_down,
   is_held,
   going_up
   )

   ##
   #  Set the height of the buttons at the top in pixels.  If not
   #  invoked, a sensible default will be used.
   #  @param x   The height
   #
   method set_button_group_height(x)
      return self.head_h := x
   end

   method get_contents()
      return self.contents
   end

   method set_checked(l)
      return self.checked := l
   end

   method get_checked()
      return self.checked
   end

   #
   # Present page size
   #
   method get_page_size()
      return (\self.vsb)$get_page_size() | *self.contents
   end

   ##
   # Move to the given position.  Either parameter may be omitted.
   # @param x   The row to move to
   # @param y   The left offset to move to
   #
   method goto_pos(x, y)
      (\self.vsb)$set_value(\x - 1)
      (\self.hsb)$set_value(\y)
      self$redisplay()
   end

   method compute_and_redisplay()
      if \ (\self.parent_Dialog).is_open then
         self$set_internal_fields()
      self$redisplay()
   end

   ##
   #  Set the contents of the table.  The parameter should be a
   #  two dimensional list.  Each element of the list should
   #  correspond to one row of the table.
   #  @param x   The contents
   #
   method set_contents(x)
      self.contents := x
      #
      # Expand/contract list if necessary
      #
      while *self.checked < *x do put(self.checked)
      while *self.checked > *x do pull(self.checked)

      compute_and_redisplay()
      return x
   end

   method clear_selections()
      self.checked := list(*contents)
      redisplay()
      return
   end

   ##
   #  Add the given TableColumn to the Table.
   #  @param c  The column to add.
   #
   method add(c)
      put(self.columns, c)
      c$set_parent_table(self)
   end

   method final_setup(x, y)
      self$Component.final_setup(x, y)
      every (!self.columns)$final_setup(x, self)
   end

   ##
   #  Configure the table so that one row of the table may be highlighted.
   #
   method set_select_one()
      self.select_one := 1
   end

   ##
   #  Configure the table so that several rows of the table may be highlighted.
   #
   method set_select_many()
      self.select_many := 1
   end

   method finally()
      self$Component.finally()
      every (!self.columns)$finally()
      (\self.vsb)$finally()
      (\self.hsb)$finally()
      self.vsb := self.hsb := &null
   end

   #
   # Return item currently under the clicked cursor
   #
   method get_which_down()
      return \self.which_down
   end

   #
   # Return row currently under the clicked cursor
   #
   method row_get_which_down()
      return self.contents[\self.which_down]
   end

   #
   # Return item currently under the clicked cursor
   #
   method get_prev_down()
      return \self.prev_down
   end

   #
   # Return row currently under the clicked cursor
   #
   method row_get_prev_down()
      return self.contents[\self.prev_down]
   end

   #
   # Return a list of items highlighted
   #
   ##
   #  Return a list of rows selected
   #  @return A list of rows currently selected
   #
   method get_selections()
      r := []
      every i := 1 to *self.checked do
         if \self.checked[i] then
            put(r, i)
      return r
   end

   ##
   #  Set the current selections to the list l, which is a list of
   #  row numbers.
   #  @param l   The list of item numbers.
   #
   method set_selections(l)
      self.checked := list(*self.contents)
      every self.checked[!l] := 1
      redisplay()
   end

   method get_last_line()
      nlines := (\self.vsb)$get_page_size() | *self.contents
      return self$get_line() + nlines - 1
   end

   method handle_press(e)
      if \ (self.select_one | self.select_many) & (self.tx <= &x < self.tx + self.tw) & (self.ty  <= &y < self.ty + self.th) then {
         #
         # Compute line clicked
         #
         l := (&y - self.ty) / self.line_height + self$get_line()
         nlines := (\self.vsb)$get_page_size() | *self.contents

         if self.which_down := (self$get_last_line() >= l) then {
            if \self.select_many & (&shift | &control) then {
               #
               # Click with shift/ctrl - the state will end here.
               #
               if &control then
                  self.checked[self.which_down] := if /self.checked[self.which_down] then 1 else &null
               else {
                  #
                  # &shift
                  #
                  if \self.prev_down then {
                     if self.prev_down > self.which_down then
                        every self.checked[self.which_down to self.prev_down] := 1
                     else
                        every self.checked[self.prev_down to self.which_down] := 1
                  } else
                     self.checked[self.which_down] := 1
               }
               self.prev_down := self.which_down
               self.which_down := &null
               self$refresh(1)
               return _Event(e, self, 1)
            } else {
               #
               # Normal click down
               #
               self.is_held := 1
               self.checked := list(*self.contents)
               self$refresh(1)
               return _Event(e, self, 0)
            }
         }
      }
   end

   method end_state()
      if \self.is_held then {
         self.is_held := &null
         stop_ticker()
         #
         # Clear flag, refresh, return event
         #
         self.checked := list(*self.contents)
         self.checked[self.which_down] := 1
         self.which_down := &null
         self.prev_down := self.which_down
         self$refresh(1)
      }
   end

   method handle_drag(e)
      local old_down, l

      if \self.is_held then {
         #
         # Mouse drag - save present marked line
         #
         old_down := self.which_down

         #
         # Mouse drag - save present marked line
         #
         old_down := self.which_down

         if &y < self.ty then {
            self.going_up := 1
            if /self.ticker_rate then
               set_ticker(self.parent_Dialog.repeat_rate)
         } else if &y > self.ty + self.th then {
            self.going_up := &null
            if /self.ticker_rate then
               set_ticker(self.parent_Dialog.repeat_rate)
         } else {
            l := (&y - self.ty) / self.line_height + self$get_line()
            l >:= self$get_last_line()
            self.which_down := l
            stop_ticker()
         }

         #
         # Refresh if line changed
         #
         if old_down ~=== self.which_down then
            self$refresh(1)
      }
   end

   method tick()
      if \going_up then {
         self.which_down := self$get_line() - 1
         self.which_down <:= 1
         (\self.vsb)$set_value(self.vsb$get_value() - 1)
      } else {
         self.which_down := self$get_last_line() + 1
         self.which_down >:= *self.contents
         (\self.vsb)$set_value(self.vsb$get_value() + 1)
      }
      self$refresh(1)
   end

   method handle_release(e)
      if \self.is_held then {
         #
         # Mouse released after being held down.  Clear flag
         #
         self.is_held := &null
         stop_ticker()
         #
         # Clear flag, refresh, return event
         #
         self.checked := list(*self.contents)
         self.checked[self.which_down] := 1
         self.prev_down := self.which_down
         self.which_down := &null
         self$refresh(1)
         return _Event(e, self, 1)
      }
   end

   method handle_key_page_up(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i - self.vsb.page_size)
         self$refresh()
      }
   end

   method handle_key_page_down(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i + self.vsb.page_size)
         self$refresh()
      }
   end

   method handle_key_up(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i - 1)
         self$refresh()
      }
   end

   method handle_key_down(e)
      if i := (\self.vsb)$get_value() then {
         self.vsb$set_value(i + 1)
         self$refresh()
      }
   end

   method handle_key_left(e)
      if i := (\self.hsb)$get_value() then {
         self.hsb$set_value(i - self.hsb.increment_size)
         self$scroll_buttons()
         self$refresh()
      }
   end

   method handle_key_right(e)
      if i := (\self.hsb)$get_value() then {
         self.hsb$set_value(i + self.hsb.increment_size)
         self$scroll_buttons()
         self$refresh()
      }
   end

   method handle_key_home(e)
      if (\self.vsb)$set_value(0) then
         self$refresh()
   end

   method handle_key_end(e)
      if (\self.vsb)$set_value(*self.contents - 1) then
         self$refresh()
   end

   method handle_notify(e)
      if e$get_component() === self.vsb then
         self$refresh()
      else if e$get_component() === self.hsb then {
         self$scroll_buttons()
         self$refresh()
      }
   end

   method handle_event(e)
      local old_down, l

      if E := (!self.columns)$handle_event(e) & E$get_code() > 0 then
          return E
      else if E := (\self.vsb)$handle_event(e) then {
         #
         # Handled by VSB; amend line number and refresh contents
         #
         self$refresh()
      } else if E := (\self.hsb)$handle_event(e) then {
         #
         # Handled by HSB; amend left offset and refresh
         #
         self$scroll_buttons()
         self$refresh()
      } else return if integer(e) = (&lpress | &rpress | &mpress) then
         handle_press(e)
      else if integer(e) = (&ldrag | &rdrag | &mdrag) then
         handle_drag(e)
      else if integer(e) = (&lrelease | &rrelease | &mrelease) then
         handle_release(e)
      else if \self.has_focus then {
         case e of {
            Key_Home : handle_key_home(e)
            Key_End : handle_key_end(e)
            Key_PgUp : handle_key_page_up(e)
            Key_PgDn : handle_key_page_down(e)
            Key_Up : handle_key_up(e)
            Key_Down : handle_key_down(e)
            Key_Left : handle_key_left(e)
            Key_Right : handle_key_right(e)
         }
      }
   end

   method resize()
      if /self.contents then
         error("no contents specified")
      /self.head_h := WAttrib(self.cwin, "fheight") +  2 * DEFAULT_TEXT_Y_SURROUND
      self$Component.resize()
      self$set_internal_fields()
   end

   method scroll_buttons()
      i := self$get_left_pos()
      every b := !self.columns do {
         b$set_pos(i - self.x, self.head_y - self.y)
         b$resize()
         i +:= b.w
      }
   end

   #
   # Called on resize, buttons resized, or contents amended
   #
   method set_internal_fields()
      every (!self.columns)$check_width()

      self.line_height := WAttrib(self.cwin, "fheight")

      #
      # Top of button region
      #
      self.head_y := self.y + BORDER_WIDTH

      #
      # Top left of text region
      #
      self.tx := self.x + TX_PADDING
      self.ty := self.head_y + self.head_h + TY_PADDING

      #
      # Initialize left_pos field, clear optimizing flags used
      # in display.
      #
      self.last_refresh_x := self.last_refresh_y := &null

      #
      # Compute maximum width
      #
      self.max_width := 0
      every self.max_width +:= (!self.columns).column_width

      #
      # Compute max/min heights/widths for text; max if no scroll bar
      # needed; min otherwise.   Deduct an extra border from max_th to
      # be even within the bottom of the whole and the bottom of the header.
      #
      max_th := self.h - self.head_h - 2 * TY_PADDING - 2 * BORDER_WIDTH
      max_tw := self.w - 2 * TX_PADDING
      min_th := max_th - SB_SIZE
      min_tw := max_tw - SB_SIZE

      #
      # Set flags indicating whether scroll bars needed.  0 => definitely not
      # 1 => yes if opposite scroll bar needed; 2 => definitely yes.
      #
      if min_th / self.line_height >= *self.contents then
         need_vsb := 0
      else if max_th / self.line_height >= *self.contents then
         need_vsb := 1
      else
         need_vsb := 2

      if min_tw >= self.max_width then
         need_hsb := 0
      else if max_tw >= self.max_width then
         need_hsb := 1
      else
         need_hsb := 2

      #
      # Case analysis on flags to set up correct scroll bars, text width
      # and height fields.
      #
      if (need_vsb < 2) & (need_hsb < 2) then {
         #
         # No scroll bars.
         #
         self.th := max_th
         self.tw := max_tw
         (\self.vsb)$finally()
         (\self.hsb)$finally()
         self.vsb := self.hsb := &null
      } else if (need_hsb + need_vsb > 2) then {
         #
         # Two scroll bars.
         #
         #
         # Two scroll bars.
         #
         if /self.vsb := ScrollBar() then
            new_vsb := 1
         if /self.hsb := ScrollBar() then {
            self.hsb$set_is_horizontal()
            new_hsb := 1
         }

         self.th := min_th
         self.tw := min_tw

         self.vsb$set_pos(self.w - SB_SIZE - BORDER_WIDTH, BORDER_WIDTH)
         self.vsb$set_size(SB_SIZE, self.h - SB_SIZE - BORDER_WIDTH * 2)

         self.hsb$set_pos(BORDER_WIDTH, self.h - SB_SIZE - BORDER_WIDTH)
         self.hsb$set_size(self.w - SB_SIZE - BORDER_WIDTH * 2, SB_SIZE)
      } else if (need_hsb = 0) & (need_vsb = 2) then {
         #
         # One vertical scroll bar.
         #
         if /self.vsb := ScrollBar() then
            new_vsb := 1
         (\self.hsb)$finally()
         self.hsb := &null

         self.th := max_th
         self.tw := min_tw

         self.vsb$set_pos(self.w - SB_SIZE - BORDER_WIDTH, BORDER_WIDTH)
         self.vsb$set_size(SB_SIZE, self.h  - BORDER_WIDTH * 2)
      } else if (need_hsb = 2) & (need_vsb = 0) then {
         #
         # One horizontal scroll bar.
         #
         if /self.hsb := ScrollBar() then {
            self.hsb$set_is_horizontal()
            new_hsb := 1
         }
         (\self.vsb)$finally()
         self.vsb := &null

         self.th := min_th
         self.tw := max_tw

         self.hsb$set_pos(BORDER_WIDTH, self.h - SB_SIZE - BORDER_WIDTH)
         self.hsb$set_size(self.w  - BORDER_WIDTH * 2, SB_SIZE)
      }

      #
      # Initialize scroll bars.
      #
      if \self.vsb then {
         self.vsb$set_page_size(self.th / self.line_height)
         self.vsb$set_total_size(*self.contents)
         if \new_vsb then {
            self.vsb$set_increment_size(1)
            self.vsb$set_value(0)
            self.vsb$final_setup(self$get_parent_Dialog(), self)
            self.vsb$resize()
            self.vsb$firstly()
         } else
            self.vsb$resize()
      }

      if \self.hsb then {
         self.hsb$set_page_size(self.tw)
         self.hsb$set_total_size(self.max_width)
         if \new_hsb then {
            self.hsb$set_increment_size(TextWidth(self.cwin, "m"))
            self.hsb$set_value(0)
            self.hsb$final_setup(self$get_parent_Dialog(), self)
            self.hsb$resize()
            self.hsb$firstly()
         } else
            self.hsb$resize()
      }

      #
      # Compute button x, y positions
      #
      self$scroll_buttons()
   end

   method get_left_pos()
      return (self.tx - (\self.hsb)$get_value()) | self.tx
   end

   method get_line()
      return  ((\self.vsb)$get_value() + 1) | 1
   end

   method display(buffer_flag)
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawSunkenRectangle(self.cbwin, self.x, self.y, self.w, self.h,-2)
      self$text_area_to_buffer()
      self$button_area_to_buffer()

      (\self.vsb)$display(1)
      (\self.hsb)$display(1)

      self$do_shading(self.cbwin)
      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   #
   # Re-draw the text area.  Use double-buffering to avoid flicker.
   #
   method refresh(redraw)
      line := self$get_line()
      left_pos := self$get_left_pos()

      #
      # Do nothing unless have to
      #
      if /redraw & (\self.last_refresh_x = line) & (\self.last_refresh_y = left_pos) then
         return


      if \redraw | not(\self.last_refresh_y = left_pos) then {
         self$button_area_to_buffer()
         CopyArea(self.cbwin, self.cwin, self.tx, self.head_y, self.tw, self.head_h, self.tx, self.head_y)
      }

      #
      # Save present co-ordinates
      #
      self.last_refresh_x := line
      self.last_refresh_y := left_pos


      text_area_to_buffer()
      self$do_shading(self.cbwin)

      #
      # Copy buffer to window
      #
      CopyArea(self.cbwin, self.cwin, self.tx, self.ty, self.tw, self.th, self.tx, self.ty)
   end

   method button_area_to_buffer()
      EraseRectangle(self.cbwin, self.tx, self.head_y, self.tw, self.head_h)
      #
      # Draw buttons into buffer
      #
      every (!self.columns)$display(1)
   end


   method text_area_to_buffer()
      local rev

      line := self$get_line()
      left_pos := self$get_left_pos()

      EraseRectangle(self.cbwin, self.tx, self.ty, self.tw, self.th)

      #
      # Number of lines to draw
      #
      nlines := (\self.vsb)$get_page_size() | *self.contents

      rev := Clone(self.cbwin, "drawop=reverse")
      yp := self.ty + self.line_height / 2

      #
      # Write the lines
      #
      every l := self.contents[i := line to line + nlines - 1] do {
         every j := 1 to *self.columns do {
            x1 := self.columns[j].x + DEFAULT_TEXT_X_SURROUND
            w1 := self.columns[j].w - 2 * DEFAULT_TEXT_X_SURROUND
            clip_x1 := x1
            clip_x1 <:= self.tx
            clip_x2 := x1 + w1
            clip_x2 >:= self.tx + self.tw

            Clip(self.cbwin, clip_x1, self.ty, clip_x2 - clip_x1, self.th)
            case self.columns[j].internal_alignment of {
               "r" :          right_string(self.cbwin, x1 + w1, yp, l[j])
               "c" :          center_string(self.cbwin, x1 + w1 / 2, yp, l[j])
               "l" :          left_string(self.cbwin, x1, yp, l[j])
            }
            Clip(self.cbwin)
         }

         if \self.checked[i] | i = \self.which_down then
            FillRectangle(rev, self.tx, yp - self.line_height / 2, self.tw, self.line_height)

         yp +:= self.line_height
      }

      Uncouple(rev)
   end

   initially
      self$Component.initially()
      self.columns := []
      self$set_accepts_tab_focus()
      self.checked := []
end

##
#  This class groups several Buttons together.  Then, when the
#  mouse is clicked down on one of the Buttons and then dragged
#  onto another before being released, the other Button will go
#  "down".  This is the common behaviour for buttons in a bar
#  along the top of an application.
#
#  NB - A Button must be added to the {ButtonGroup} and the
#  {Dialog} too.
#  @example
#  @ bg := ButtonGroup()
#  @ b := TextButton()
#  @ b$set_label("Okay")
#  @ self$add(b)
#  @ bg$add(b)
#
class ButtonGroup(
   buttons
   )

   ##
   #  Add the given {Button} to the {ButtonGroup}.
   #  @param c   The {Button} to add
   #
   method add(c)
      put(self.buttons, c)
      c$set_parent_button_group(self)
   end

   initially
      self.buttons := []
end


$define X_PADDING_INC 5


##
#  This class represents a single pane in a {TabSet}.  {Components}
#  can be added to the {TabItem} using {Container}'s {add} method.
#  They are then displayed and accept input when that TabItem
#  is selected.
#
#  Components added to the {TabItem} are positioned relative to
#  the position and size of the parent {TabSet}.  Therefore for
#  example {set_pos("50%", "50%")} refers to the centre of the
#  {TabSet} rather than the centre of the screen.  The components
#  also inherit any window attributes of the {TabSet}, such as
#  font, colour and so on.
#
class TabItem : Container(
   label,
   label_x,
   line_no,
   label_w,
   parent_tab_set
   )

   method set_parent_tab_set(x)
      return self.parent_tab_set := x
   end

   ##
   #  Set the {TabItem}'s label.
   #
   method set_label(x)
      return self.label := x
   end

   method check_label()
      if /self.label then
         error("no label specified")
   end

   method is_hidden()
      return parent_tab_set.which_one ~=== self
   end

   method is_unhidden()
      return parent_tab_set.which_one === self
   end

   method display_tab()
      ypos := (self.line_no - 1) * self.parent_tab_set.line_h + self.parent_tab_set.y
      cw := Clone(self.parent_tab_set.cbwin)
      Fg(cw, "black")
      DrawLine(cw, self.label_x + self.label_w - 1, ypos, self.label_x + self.label_w - 1, ypos + self.parent_tab_set.line_h - 1)
      DrawLine(cw, self.label_x + self.label_w - 2, ypos + 1, self.label_x + self.label_w - 2, ypos + self.parent_tab_set.line_h - 2)
      Fg(cw, "pale gray")
      DrawLine(cw, self.label_x, ypos + self.parent_tab_set.line_h - 1, self.label_x, ypos, self.label_x + self.label_w - 1, ypos)
      Fg(cw, "white")
      DrawLine(cw, self.label_x + 1, ypos + self.parent_tab_set.line_h - 2, self.label_x + 1, ypos + 1, self.label_x + self.label_w - 2, ypos  + 1)
      Uncouple(cw)

      left_string(self.parent_tab_set.cbwin, self.label_x + DEFAULT_TEXT_X_SURROUND, ypos + self.parent_tab_set.line_h / 2, self.label)

      if is_shaded() then
         FilterRectangle(self.parent_tab_set.cbwin, self.label_x, ypos + 2, self.label_w - 2, self.parent_tab_set.line_h - 1)
   end

end

##
#  This class holds the several {TabItems}, and represents a tabbed pane.
#
class TabSet : VisibleContainer(
   which_one,
   tab_h,
   lines,
   line_h,
   line_break
   )

   method get_x_reference()
      return self.x
   end

   method get_y_reference()
      return self.y + self.tab_h
   end

   method get_w_reference()
      return self.w
   end

   method get_h_reference()
      return self.h - self.tab_h
   end

   method display(buffer_flag)
      local last_on_a_line

      #
      # Erase all and display outline of tabbed pane area.
      #
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      DrawRaisedRectangle(self.cbwin, self.x, self.y, self.w, self.h,2)

      #
      # Display all tabs.
      #
      every (!!self.line_break)$display_tab()

      last_on_a_line := (!self.line_break)[-1] === self.which_one

      #
      # Display line under tabs.
      #
      cw := Clone(self.cbwin)
      Fg(cw, "pale gray")
      DrawLine(cw, self.x, self.y + self.tab_h - 2, self.which_one.label_x, self.y + self.tab_h - 2)
      if /last_on_a_line then
         DrawLine(cw, self.which_one.label_x + self.which_one.label_w, self.y + self.tab_h - 2, self.x + self.w - 1, self.y + self.tab_h - 2)
      Fg(cw, "white")
      DrawLine(cw, self.x, self.y + self.tab_h - 1, self.which_one.label_x, self.y + self.tab_h - 1)
      if /last_on_a_line then
         DrawLine(cw, self.which_one.label_x + self.which_one.label_w, self.y + self.tab_h - 1, self.x + self.w - 2, self.y + self.tab_h - 1)

      Uncouple(cw)

      #
      # Display contents of current tab into buffer
      #
      which_one$display(1)

      self$do_shading(self.cbwin)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   #
   # Determine which tab if any mouse is over.
   #
   method which_tab()
      l := (&y - self.y) / self.line_h + 1
      every c := !self.line_break[l] do {
         if c.is_unshaded() & (c.label_x <= &x < c.label_x + c.label_w) then
            return c
      }
   end

   method in_region()
      return  self.which_one$in_region() | self$Component.in_region()
   end

   #
   # Ensure which_one is at front of tab lines
   #
   method adjust_lines()
      l := self.which_one.line_no
      self.line_break[l] :=: self.line_break[self.lines]
      every (!self.line_break[l]).line_no := l
      every (!self.line_break[self.lines]).line_no := self.lines
   end

   ##
   #  Set which tab is currently on display.
   #  @param x  The {TabItem} to be displayed.
   #
   method set_which_one(x)
      if \ (\self.parent_Dialog).is_open then {
         self.which_one := x
         self$adjust_lines()
         self$display()
      } else
         self.which_one := x

      return x
   end

   method handle_event(e)
      if integer(e) = (&lpress | &rpress | &mpress) & (self.y <= &y < self.y + self.tab_h) then
         self$set_which_one(which_tab())

      suspend which_one$handle_event(e)
   end

   method generate_components()
      suspend self.which_one$generate_components() | self
   end

   method generate_all_components()
      suspend (!self.components)$generate_all_components() | self
   end

   ##
   #  Add the given TabItem to the TabSet.
   #
   method add(c)
      c$set_parent_tab_set(self)
      self$VisibleContainer.add(c)
   end

   #
   # Break the set of tabs up into lines, given the padding within each tab.
   # Returns a list each element of which is a list of those tabs on one line.
   #
   method how_many_lines(pad)
      t := 0
      l := []
      cl := []
      every c := !self.components do {
         lw := TextWidth(self.cwin, c.label) + pad
         if (t > 0) & (t + lw > self.w) then {
            #
            # New line required.
            #
            t := 0
            put(l, cl)
            cl := []
         }
         t +:= lw
         put(cl, c)
      }
      #
      # Final line, if any
      #
      if t > 0 then
         put(l, cl)

      return l
   end

   method resize()
      if *self.components = 0 then
         error("no TabItems in TabSet")

      every (!self.components)$check_label()

      self$Component.resize()

      #
      # Determine how many lines for minimum padding.
      #
      pad := 2 * DEFAULT_TEXT_X_SURROUND
      self.lines := *(line_break := how_many_lines(pad))

      self.line_h := WAttrib(self.cwin, "fheight") + 2 * DEFAULT_TEXT_Y_SURROUND
      self.tab_h :=  self.line_h * self.lines

      #
      # Expand padding whilst can do so and remain within the original
      # number of lines.  This should even out the tabs.
      #
      if 1 < self.lines < *self.components then {
         while *(l2 := how_many_lines(pad + X_PADDING_INC)) <= self.lines do {
            self.line_break := l2
            pad +:= X_PADDING_INC
         }
      }

      #
      # Finally, space out the tabs on each line to fill up each line.
      #
      n := 1
      every curr_line := !self.line_break do {
         #
         # Work out total already used.
         #
         t := 0
         every c := !curr_line do {
            c.label_w := TextWidth(self.cwin, c.label) + pad
            c.line_no := n
            t +:= c.label_w
         }

         #
         # Amount to add to each tab.
         #
         d := (self.w - t) / *curr_line

         #
         # Add the amount, compute new total
         #
         t := 0
         every c := !curr_line do {
            c.label_x := self.x + t
            c.label_w +:= d
            t +:= c.label_w
         }

         #
         # Add residual amount to rightmost tab.
         #
         curr_line[-1].label_w +:= self.w - t
         n +:= 1
      }

      every (!self.components)$resize()

      /self.which_one := self.components[1]
      self$adjust_lines()
   end
end


##
#  This class is one "pane" in an {OverlaySet}, which is rather
#  like a {TabSet} except that there are no tabs, and control
#  over which pane is displayed is entirely the affair of the
#  program.
#
#  The components inside have their size and position computed
#  relative to the parent OverlaySet and also inherit the
#  OverlaySet's windowing attributes.
#  Components are added using the {add} method of {Container}.
#
class OverlayItem : Container(
   parent_overlay_set
   )

   method is_hidden()
      return parent_overlay_set.which_one ~=== self
   end

   method is_unhidden()
      return parent_overlay_set.which_one === self
   end

   method set_parent_overlay_set(x)
      return self.parent_overlay_set := x
   end
end

##
#  This class provides a container which contains several {OverlayItems}, only one
#  of which is visible at a time.
#
class OverlaySet : VisibleContainer(
   which_one              #
   )

   method display(buffer_flag)
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)

      #
      # Display contents of current tab into buffer
      #
      which_one$display(1)

      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
   end

   method in_region()
      return  self.which_one$in_region() | self$Component.in_region()
   end

   ##
   #  Set which OverlayItem is currently displayed.  The default is
   #  the first which was added.
   #
   method set_which_one(x)
      if \ (\self.parent_Dialog).is_open then {
         self.which_one := x
         self$display()
      } else
         self.which_one := x
      return x
   end

   method handle_event(e)
      suspend which_one$handle_event(e)
   end

   method generate_components()
      suspend self.which_one$generate_components() | self
   end

   method generate_all_components()
      suspend self.which_one$generate_components() | self
   end

   ##
   #  Add the given OverlayItem to the OverlaySet.
   #
   method add(c)
      c$set_parent_overlay_set(self)
      self$VisibleContainer.add(c)
   end

   method resize()
      if *self.components = 0 then
         error("no OverlayItems in OverlaySet")

      self$Component.resize()

      every (!self.components)$resize()
      /self.which_one := self.components[1]
   end
end

##
#  This class is a {Panel} which may have {Component}s added to it
#  in the normal way.  However, the {Component}s within it will produce
#  tooltip labels when the mouse cursor is held over them for a short
#  period of time.   The tooltip strings may be set using the {set_tooltip}
#  method of {Component}.
#
class ToolBar : Panel(
   last_obj,
   state,
   start_time,
   end_time,
   start_delay,
   end_delay,
   temp_win,
   temp_x,
   temp_y,
   temp_w,
   temp_h
   )

   method firstly()
      self$Panel.firstly()
      set_ticker(200)
      state := 5
   end

   method finally()
      if state = 2 then
         hide_label()
      self$Panel.finally()
   end

   ##
   #  Configure the delays used in making the tooltips appear.
   #  @param x   The starting delay, ie the period before a tooltip appears.
   #  @param y   The end delay, namely how long the tooltip stays visible.
   #
   method set_start_end_delays(x, y)
      self.start_delay := x
      self.end_delay := y
   end

   method show_label(x, y, label)
      local cw, ww, wh

      ww := WAttrib(self$get_parent_win(), "width")
      wh := WAttrib(self$get_parent_win(), "height")

      cw := Clone(self.cwin, "bg=pale yellow", "font=sans,10", "fg=black")

      temp_w := TextWidth(cw, label) + 4
      temp_h := WAttrib(cw, "fheight") +  6

      temp_x := x + 4
      if temp_x + temp_w > ww then
         temp_x := 0 <= ww - temp_w

      temp_y := self.y + self.h + 3
      if temp_y + temp_h > wh then
         temp_y := 0 <= wh - temp_h

      self.temp_win := WOpen("canvas=hidden", "size=" || temp_w || "," || temp_h)
      CopyArea(get_parent_win(), temp_win, temp_x, temp_y, temp_w, temp_h, 0, 0)
      EraseRectangle(cw, temp_x, temp_y, temp_w, temp_h)
      Rectangle(cw, temp_x, temp_y, temp_w, temp_h)
      center_string(cw, temp_x + temp_w / 2, temp_y + temp_h / 2, label)
      Uncouple(cw)
   end

   method hide_label()
      CopyArea(temp_win, get_parent_win(), 0, 0, temp_w, temp_h, temp_x, temp_y)
      WClose(temp_win)
      temp_win := &null
   end

   method tick()
      local obj, x1, y1, s, c, t, in_region

      #
      # Don't process ticks whilst unique mode on, or toolbar hidden
      #
      if \parent_Dialog.unique_flag | is_hidden() then
         return

      #
      # If it is blocked, then equivalent to moving outside the toolbar.
      #
      if /parent_Dialog.is_blocked_flag then {
         x1 := WAttrib(self.parent_Dialog.win, "pointerx")
         y1 := WAttrib(self.parent_Dialog.win, "pointery")

         #
         # If within toolbar bar area then ...
         #
         in_region := ((self.x <= x1 < self.x + self.w) & (self.y  <= y1 < self.y + self.h))

         if \in_region then {
            #
            # Work out which object it is over
            #
            every c := self$generate_components() do {
               if \c.tooltip & ((c.x <= x1 < c.x + c.w) & (c.y  <= y1 < c.y + c.h)) then {
                  obj := c
                  break
               }
            }
         }
      }

      t := dispatcher$curr_time_of_day()

      if obj ~=== last_obj then {
         if /obj then
            state := if state = 2 then 3 else 4
         else {
            if state = 2 then
               hide_label()
            start_time := t
            if state = 5 then
               start_time +:= start_delay
            state := 1
            end_time := start_time + end_delay
         }
         last_obj := obj
      }

      if state = 1 & t >= start_time then {
         #
         # Change label.
         #
         show_label(x1, y1, c.tooltip)
         state := 2
      }
      if state = 2 & t >= end_time then
         state := 3
      if state = 3 then {
         hide_label()
         state := 4
      }
      if state = 4 & /in_region then
         state := 5
   end

   method handle_event(e)
      if not(integer(e) = (&ldrag | &rdrag | &mdrag)) then {
         if state = 2 then
            hide_label()

         state := 5
      }
      suspend self$Panel.handle_event(e)
   end

   method display(buffer_flag)
      EraseRectangle(self.cbwin, self.x, self.y, self.w, self.h)
      if \self.draw_border_flag then
         DrawRaisedRectangle(self.cbwin, self.x, self.y, self.w, self.h,2)
      every (!self.components)$display(1)
      if /buffer_flag then
         CopyArea(self.cbwin, self.cwin, self.x, self.y, self.w, self.h, self.x, self.y)
      return
   end

   initially
      self$Panel.initially()
      start_delay := 1000
      end_delay := 3000
end

procedure EraseRectangle(W, x, y, w, h)
   if x < 0 then {
      w +:= x
      x := 0
   }

   return EraseArea(W, x, y, w, h)
end

procedure Rectangle(W, x, y, w, h)
   return DrawRectangle(W, x, y, w - 1, h - 1)
end

#
# Draw a raised rectangle.
#
procedure DrawRaisedRectangle(W, x, y, w, h, i)
   BevelRectangle(W, x, y, w, h, i)
end

#
# Draw a sunken rectangle.
#
procedure DrawSunkenRectangle(W, x, y, w, h, i)
   BevelRectangle(W, x, y, w, h, i)
end

procedure FilterRectangle(W, x, y, w, h)
$ifdef _MS_WINDOWS_NT
   cw := Clone(W, "fillstyle=masked", "drawop=reverse", "pattern=verydark")
   FillRectangle(cw, x, y, w, h)
$else
   cw := Clone(W, "fillstyle=masked", "reverse=on", "pattern=waves")
   FillRectangle(cw, x, y, w, h)
$endif
   Uncouple(cw)
end

procedure left_string(win, x, y, s)
   y +:= (WAttrib(win, "ascent") - WAttrib(win, "descent")) / 2
   return DrawString(win, x, y, s)
end

procedure left_stringr(win, x, y, s)
   y +:= (WAttrib(win, "ascent") - WAttrib(win, "descent")) / 2
   Fg(win, "black")
   rv := DrawString(win, x, y, s)
   return rv
end
procedure left_stringg(win, x, y, s)
   y +:= (WAttrib(win, "ascent") - WAttrib(win, "descent")) / 2
   oldfg := Fg(win)
   oldbg := Bg(win)
   WAttrib(win, "fg=red")
   WAttrib(win, "bg=gray")
   rv := DrawString(win, x, y, s)
   Fg(win, oldfg)
   Bg(win, oldbg)
   return rv
end

procedure center_string(win, x, y, s)
   x -:= TextWidth(win, s) / 2
   y +:= (WAttrib(win, "ascent") - WAttrib(win, "descent")) / 2
   return DrawString(win, x, y, s)
end

procedure right_string(win, x, y, s)
   x -:= TextWidth(win, s)
   y +:= (WAttrib(win, "ascent") - WAttrib(win, "descent")) / 2
   return DrawString(win, x, y, s)
end

procedure object_class_name(o)
   image(o) ? {
      ="record "
      return tab(find("__")) | "?"
   }
end

procedure img_width(s)
   return s ? integer(tab(upto(',')))
end

procedure img_height(s)
   s ? {
      w := integer(tab(upto(',')))
      move(1)
      tab(upto(','))
      move(1)
      return *tab(0) / (0 ~= \w)
   }
end

procedure img_style(s)
   return case s of {
      "box_up" :
"11,g2,_
11111111111_
11111111110_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11~~~~~~~00_
11000000000_
10000000000_
"
         "box_down" :
"11,g2,_
00000000001_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
00000000011_
01111111111_
11111111111_
"
      "diamond_up" :
"11,g5,_
~~~~~4~~~~~_
~~~~444~~~~_
~~~44~44~~~_
~~44~~~44~~_
~44~~~~~44~_
44~~~~~~~44_
~00~~~~~00~_
~~00~~~00~~_
~~~00~00~~~_
~~~~000~~~~_
~~~~~0~~~~~_
"
         "diamond_down" :
"11,g5,_
~~~~~0~~~~~_
~~~~000~~~~_
~~~00000~~~_
~~0000000~~_
~000000000~_
00000000000_
~440000044~_
~~4400044~~_
~~~44044~~~_
~~~~444~~~~_
~~~~~4~~~~~_
"
      "arrow_up" :
"11,c1,_
~~~~~0~~~~~_
~~~~000~~~~_
~~~00000~~~_
~~0000000~~_
~000000000~_
00000000000_
"
      "arrow_down" :
"11,c1,_
00000000000_
~000000000~_
~~0000000~~_
~~~00000~~~_
~~~~000~~~~_
~~~~~0~~~~~_
"
      "arrow_left" :
"9,c1,_
~~~~~~~~0_
~~~~~~000_
~~~~00000_
~~0000000_
000000000_
~~0000000_
~~~~00000_
~~~~~~000_
~~~~~~~~0_
"
      "arrow_right" : "9,c1,_
0~~~~~~~~_
000~~~~~~_
00000~~~~_
0000000~~_
000000000_
0000000~~_
00000~~~~_
000~~~~~~_
0~~~~~~~~_
"
      "closed_folder" : "16,c1,_
~~~~~~~~~~~~~~~~_
~~~~0000~~~~~~~~_
~~~0;;;;0~~~~~~~_
~~0;;;;;;0~~~~~~_
~0000000000000~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0;;;;;;;;;;;0~~_
~0000000000000~~_
~~~~~~~~~~~~~~~~_
"

      "open_folder" : "16,c1,_
~~~~~~~~~~~~~~~~_
~~~0000~~~~~~~~~_
~~0DDDD0~~~~~~~~_
~0DDDDDD0~~~~~~~_
0000000000000~~~_
02D2D2D2D2D20~~~_
0D2D000000000000_
02D0DDDDDDDDDDD0_
0D20DDDDDDDDDD0~_
020DDDDDDDDDDD0~_
0D0DDDDDDDDDDD0~_
00DDDDDDDDDD00~~_
0000000000000~~~_
~~~~~~~~~~~~~~~~_
"

      "file" : "16,c1,_
~~~~~~~~~~~~~~~~_
~~~0000000~~~~~~_
~~~06666600~~~~~_
~~~0606060~0~~~~_
~~~0666660000~~~_
~~~0600606660~~~_
~~~0666666660~~~_
~~~0600600060~~~_
~~~0666666660~~~_
~~~0600060660~~~_
~~~0666666660~~~_
~~~0666666660~~~_
~~~0000000000~~~_
~~~~~~~~~~~~~~~~_
"

      "plus" : "9,g2,_
000000000_
0~~~~~~~0_
0~~~0~~~0_
0~~~0~~~0_
0~00000~0_
0~~~0~~~0_
0~~~0~~~0_
0~~~~~~~0_
000000000_
"

      "minus" : "9,g2,_
000000000_
0~~~~~~~0_
0~~~~~~~0_
0~~~~~~~0_
0~00000~0_
0~~~~~~~0_
0~~~~~~~0_
0~~~~~~~0_
000000000_
"

      default : stop("unknown image style")
   }
end

procedure set_CheckBoxes_by_flag(i, checkboxes)
   j := 1
   every c := !checkboxes do {
      if iand(i, j) ~= 0 then
         c$toggle_is_checked()
      j *:= 2
   }
end

procedure get_CheckBoxes_by_flag(checkboxes)
   i := 1
   j := 0
   every c := !checkboxes do {
      if c$is_checked() then
         j +:= i
      i *:= 2
   }
   return j
end
